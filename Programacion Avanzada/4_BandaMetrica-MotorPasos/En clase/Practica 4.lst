CCS PCH C Compiler, Version 5.112, 29001               07-sep.-23 14:19

               Filename:   C:\Users\diego\Desktop\Programacion Avanzada\Practicas\Practica 4\En clase\Practica 4.lst

               ROM used:   204 bytes (1%)
                           Largest free fragment is 32564
               RAM used:   10 (0%) at main() level
                           11 (1%) worst case
               Stack used: 0 locations
               Stack size: 31

*
0000:  GOTO   0030
.................... #include <18f4550.h>   // Libreria del Microcontrolador
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
.................... 
.................... #list
.................... 
.................... #device adc = 8
.................... #fuses XT, NOWDT, NOPROTECT, NOLVP, CPUDIV1, PLL1, NOMCLR // Fusibles (Configuraciones del microcontrolador)
.................... #use delay(clock = 4M) // 4 Megahertz
0004:  CLRF   FEA
0006:  MOVLW  0B
0008:  MOVWF  FE9
000A:  MOVF   FEF,W
000C:  BTFSC  FD8.2
000E:  GOTO   002E
0012:  MOVLW  01
0014:  MOVWF  01
0016:  CLRF   00
0018:  DECFSZ 00,F
001A:  BRA    0018
001C:  DECFSZ 01,F
001E:  BRA    0016
0020:  MOVLW  4A
0022:  MOVWF  00
0024:  DECFSZ 00,F
0026:  BRA    0024
0028:  BRA    002A
002A:  DECFSZ FEF,F
002C:  BRA    0012
002E:  RETURN 0
.................... 
.................... void main()
0030:  CLRF   FF8
0032:  BCF    FD0.7
0034:  MOVF   FC1,W
0036:  ANDLW  C0
0038:  IORLW  0F
003A:  MOVWF  FC1
003C:  MOVLW  07
003E:  MOVWF  FB4
0040:  CLRF   06
0042:  CLRF   05
.................... {
....................    int16 data = 0;
....................    
....................    setup_adc(adc_clock_div_2); // Sincronizamos las frecuencias
0044:  MOVF   FC0,W
0046:  ANDLW  C0
0048:  MOVWF  FC0
004A:  BCF    FC0.7
004C:  BSF    FC2.0
....................    setup_adc_ports(AN0); // Hay un sensor en AN0
004E:  MOVF   FC1,W
0050:  ANDLW  C0
0052:  IORLW  0E
0054:  MOVWF  FC1
....................    set_tris_a(0b00000001); // 1 entrada 0 salida
0056:  MOVLW  01
0058:  MOVWF  F92
....................    set_adc_channel(0);
005A:  MOVLW  00
005C:  MOVWF  01
005E:  MOVF   FC2,W
0060:  ANDLW  C3
0062:  IORWF  01,W
0064:  MOVWF  FC2
....................    delay_us(20);
0066:  MOVLW  06
0068:  MOVWF  00
006A:  DECFSZ 00,F
006C:  BRA    006A
006E:  NOP   
....................    
....................    delay_ms(2000);
0070:  MOVLW  08
0072:  MOVWF  08
0074:  MOVLW  FA
0076:  MOVWF  0B
0078:  RCALL  0004
007A:  DECFSZ 08,F
007C:  BRA    0074
....................    
....................    while(true)
....................    {
....................       data = read_adc(); // Obtiene la lectura del sensor
007E:  BSF    FC2.1
0080:  BTFSC  FC2.1
0082:  BRA    0080
0084:  CLRF   06
0086:  MOVFF  FC4,05
....................       
....................       for(int i = 1; i<=8; i*=2)
008A:  MOVLW  01
008C:  MOVWF  07
008E:  MOVF   07,W
0090:  SUBLW  08
0092:  BNC   00C2
....................       {
....................          output_b(i);
0094:  CLRF   F93
0096:  MOVFF  07,F8A
....................          delay_ms(data+64);
009A:  MOVLW  40
009C:  ADDWF  05,W
009E:  MOVWF  08
00A0:  MOVLW  00
00A2:  ADDWFC 06,W
00A4:  MOVWF  09
00A6:  MOVWF  0A
00A8:  INCF   0A,F
00AA:  DECF   0A,F
00AC:  BTFSC  FD8.2
00AE:  BRA    00B6
00B0:  SETF   0B
00B2:  RCALL  0004
00B4:  BRA    00AA
00B6:  MOVFF  08,0B
00BA:  RCALL  0004
00BC:  BCF    FD8.0
00BE:  RLCF   07,F
00C0:  BRA    008E
....................       }
....................       output_d(data); // Imprime en los leds el valor recibido por el sensor
00C2:  CLRF   F95
00C4:  MOVFF  05,F8C
00C8:  BRA    007E
....................    }
.................... }
00CA:  SLEEP 

Configuration Fuses:
   Word  1: C020   PLL1 CPUDIV1 USBDIV XT FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
