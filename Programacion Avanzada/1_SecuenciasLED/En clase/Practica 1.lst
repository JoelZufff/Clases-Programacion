CCS PCH C Compiler, Version 5.112, 29001               12-ago.-23 21:06

               Filename:   C:\Users\diego\Desktop\Programacion Avanzada\Practicas\Practica 1\Practica 1.lst

               ROM used:   302 bytes (1%)
                           Largest free fragment is 32466
               RAM used:   6 (0%) at main() level
                           7 (0%) worst case
               Stack used: 0 locations
               Stack size: 31

*
0000:  GOTO   002E
.................... #include <18f4550.h>   // Libreria del Microcontrolador
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
.................... 
.................... #list
.................... 
.................... #fuses INTRC, NOWDT, NOPROTECT, NOLVP, CPUDIV1, PLL1, NOMCLR // Fusibles (Configuraciones del microcontrolador)
.................... #use delay(clock = 8M)  // 4M es 4 millones. Establecemos la velocidad va a operar el micro
0004:  CLRF   FEA
0006:  MOVLW  07
0008:  MOVWF  FE9
000A:  MOVF   FEF,W
000C:  BTFSC  FD8.2
000E:  GOTO   002C
0012:  MOVLW  02
0014:  MOVWF  01
0016:  CLRF   00
0018:  DECFSZ 00,F
001A:  BRA    0018
001C:  DECFSZ 01,F
001E:  BRA    0016
0020:  MOVLW  97
0022:  MOVWF  00
0024:  DECFSZ 00,F
0026:  BRA    0024
0028:  DECFSZ FEF,F
002A:  BRA    0012
002C:  RETURN 0
.................... 
.................... void main()
002E:  CLRF   FF8
0030:  BCF    FD0.7
0032:  MOVLW  70
0034:  MOVWF  FD3
0036:  MOVF   FD3,W
0038:  MOVF   FC1,W
003A:  ANDLW  C0
003C:  IORLW  0F
003E:  MOVWF  FC1
0040:  MOVLW  07
0042:  MOVWF  FB4
0044:  CLRF   06
0046:  CLRF   05
.................... {
....................    int16 i=0; // Los enteros tienen 1 byte le ponemos int16 para evitar eso
....................    
....................    while(true)
....................    {  
....................       for(i = 1; input(pin_d0) && !input(pin_d1); i*=2) // Primer Boton
0048:  CLRF   06
004A:  MOVLW  01
004C:  MOVWF  05
004E:  BSF    F95.0
0050:  BTFSS  F83.0
0052:  BRA    007E
0054:  BSF    F95.1
0056:  BTFSC  F83.1
0058:  BRA    007E
....................       {
....................          if(i > 128)
005A:  MOVF   06,F
005C:  BNZ   0064
005E:  MOVF   05,W
0060:  SUBLW  80
0062:  BC    006A
....................             i = 1;
0064:  CLRF   06
0066:  MOVLW  01
0068:  MOVWF  05
....................             
....................          output_b(i);
006A:  CLRF   F93
006C:  MOVFF  05,F8A
....................          delay_ms(200);
0070:  MOVLW  C8
0072:  MOVWF  07
0074:  RCALL  0004
0076:  BCF    FD8.0
0078:  RLCF   05,F
007A:  RLCF   06,F
007C:  BRA    004E
....................       }
....................       output_b(0);
007E:  CLRF   F93
0080:  CLRF   F8A
....................       
....................       for(i = 128; !input(pin_d0) && input(pin_d1) ; i/=2) // Segundo Boton
0082:  CLRF   06
0084:  MOVLW  80
0086:  MOVWF  05
0088:  BSF    F95.0
008A:  BTFSC  F83.0
008C:  BRA    00B6
008E:  BSF    F95.1
0090:  BTFSS  F83.1
0092:  BRA    00B6
....................       {
....................          if(i < 1)
0094:  MOVF   05,F
0096:  BNZ   00A2
0098:  MOVF   06,F
009A:  BNZ   00A2
....................             i = 128;
009C:  CLRF   06
009E:  MOVLW  80
00A0:  MOVWF  05
....................             
....................          output_b(i);
00A2:  CLRF   F93
00A4:  MOVFF  05,F8A
....................          delay_ms(200);
00A8:  MOVLW  C8
00AA:  MOVWF  07
00AC:  RCALL  0004
00AE:  BCF    FD8.0
00B0:  RRCF   06,F
00B2:  RRCF   05,F
00B4:  BRA    0088
....................       }
....................       output_b(0);
00B6:  CLRF   F93
00B8:  CLRF   F8A
....................       
....................       for(i = 1; !input(pin_d0) && !input(pin_d1); i++) // Ningun Boton
00BA:  CLRF   06
00BC:  MOVLW  01
00BE:  MOVWF  05
00C0:  BSF    F95.0
00C2:  BTFSC  F83.0
00C4:  BRA    00EA
00C6:  BSF    F95.1
00C8:  BTFSC  F83.1
00CA:  BRA    00EA
....................       {
....................          output_b(i);
00CC:  CLRF   F93
00CE:  MOVFF  05,F8A
....................          delay_ms(100);
00D2:  MOVLW  64
00D4:  MOVWF  07
00D6:  RCALL  0004
....................          
....................          if(i >= 256)
00D8:  MOVF   06,W
00DA:  SUBLW  00
00DC:  BC    00E2
....................             i = 0;
00DE:  CLRF   06
00E0:  CLRF   05
00E2:  INCF   05,F
00E4:  BTFSC  FD8.2
00E6:  INCF   06,F
00E8:  BRA    00C0
....................       }
....................       output_b(0);
00EA:  CLRF   F93
00EC:  CLRF   F8A
....................      
....................       for(i = 256; input(pin_d0) && input(pin_d1); i--) // Los 2 botones
00EE:  MOVLW  01
00F0:  MOVWF  06
00F2:  CLRF   05
00F4:  BSF    F95.0
00F6:  BTFSS  F83.0
00F8:  BRA    0126
00FA:  BSF    F95.1
00FC:  BTFSS  F83.1
00FE:  BRA    0126
....................       {
....................          output_b(i);
0100:  CLRF   F93
0102:  MOVFF  05,F8A
....................          delay_ms(100);
0106:  MOVLW  64
0108:  MOVWF  07
010A:  RCALL  0004
....................          
....................          if(i <= 1)
010C:  MOVF   06,F
010E:  BNZ   011C
0110:  MOVF   05,W
0112:  SUBLW  01
0114:  BNC   011C
....................             i = 256;  
0116:  MOVLW  01
0118:  MOVWF  06
011A:  CLRF   05
011C:  MOVF   05,W
011E:  BTFSC  FD8.2
0120:  DECF   06,F
0122:  DECF   05,F
0124:  BRA    00F4
....................       }
....................       output_b(0);
0126:  CLRF   F93
0128:  CLRF   F8A
012A:  BRA    0048
....................       
....................    }
.................... }
012C:  SLEEP 

Configuration Fuses:
   Word  1: C920   PLL1 CPUDIV1 USBDIV INTRC FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
