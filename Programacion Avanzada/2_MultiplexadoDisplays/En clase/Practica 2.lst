CCS PCH C Compiler, Version 5.112, 29001               23-ago.-23 21:50

               Filename:   C:\Users\diego\Desktop\Programacion Avanzada\Practicas\Practica 2\En clase\Practica 2.lst

               ROM used:   320 bytes (1%)
                           Largest free fragment is 32448
               RAM used:   18 (1%) at main() level
                           21 (1%) worst case
               Stack used: 0 locations
               Stack size: 31

*
0000:  GOTO   0074
.................... #include <18f4550.h>   // Libreria del Microcontrolador
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
.................... 
.................... #list
.................... 
.................... #fuses INTRC, NOWDT, NOPROTECT, NOLVP, CPUDIV1, PLL1, NOMCLR // Fusibles (Configuraciones del microcontrolador)
.................... #use delay(clock = 8M)  // 4M es 4 millones. Establecemos la velocidad va a operar el micro
0004:  CLRF   FEA
0006:  MOVLW  14
0008:  MOVWF  FE9
000A:  MOVF   FEF,W
000C:  BTFSC  FD8.2
000E:  GOTO   002C
0012:  MOVLW  02
0014:  MOVWF  01
0016:  CLRF   00
0018:  DECFSZ 00,F
001A:  BRA    0018
001C:  DECFSZ 01,F
001E:  BRA    0016
0020:  MOVLW  97
0022:  MOVWF  00
0024:  DECFSZ 00,F
0026:  BRA    0024
0028:  DECFSZ FEF,F
002A:  BRA    0012
002C:  RETURN 0
.................... 
.................... #define Display1 pin_a3
.................... #define Display2 pin_a4
.................... #define Inicio pin_a0
.................... #define Pausa pin_a1
.................... #define Reinicio pin_a2
.................... 
.................... void displays(int d, int u);
.................... 
.................... int vec_c[10] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D,0x7D,0x07,0x7F,0x67};
.................... 
.................... void main()
*
0074:  CLRF   FF8
0076:  BCF    FD0.7
0078:  MOVLW  70
007A:  MOVWF  FD3
007C:  MOVF   FD3,W
007E:  MOVF   FC1,W
0080:  ANDLW  C0
0082:  IORLW  0F
0084:  MOVWF  FC1
0086:  MOVLW  07
0088:  MOVWF  FB4
008A:  MOVLW  3F
008C:  MOVWF  04
008E:  MOVLW  06
0090:  MOVWF  05
0092:  MOVLW  5B
0094:  MOVWF  06
0096:  MOVLW  4F
0098:  MOVWF  07
009A:  MOVLW  66
009C:  MOVWF  08
009E:  MOVLW  6D
00A0:  MOVWF  09
00A2:  MOVLW  7D
00A4:  MOVWF  0A
00A6:  MOVLW  07
00A8:  MOVWF  0B
00AA:  MOVLW  7F
00AC:  MOVWF  0C
00AE:  MOVLW  67
00B0:  MOVWF  0D
00B2:  CLRF   0E
00B4:  CLRF   0F
00B6:  CLRF   10
00B8:  CLRF   11
.................... {
....................    int i=0,j=0, time = 0, B = 0;
....................    
....................    while(true)
....................    {
....................       loop:
....................       B = 0;
00BA:  CLRF   11
....................       for(j=0;j<10;j++)
00BC:  CLRF   0F
00BE:  MOVF   0F,W
00C0:  SUBLW  09
00C2:  BNC   013A
....................          for(i=0;i<10;i++)
00C4:  CLRF   0E
00C6:  MOVF   0E,W
00C8:  SUBLW  09
00CA:  BNC   0136
....................          {
....................             for(time = 0; (time < 50) || B; time++ ) // Se imprime las decenas y unidades correspondientes 50 veces (1 seg). Si esta la pausa se queda ahi
00CC:  CLRF   10
00CE:  MOVF   10,W
00D0:  SUBLW  31
00D2:  BC    00D8
00D4:  MOVF   11,F
00D6:  BZ    0132
....................             {
....................                displays(j,i);
00D8:  MOVFF  0F,12
00DC:  MOVFF  0E,13
00E0:  MOVLB  0
00E2:  RCALL  002E
....................                
....................                if(input(Pausa) && !B) // B es 0 (No se ha pausado)
00E4:  BSF    F92.1
00E6:  BTFSS  F80.1
00E8:  BRA    0106
00EA:  MOVF   11,F
00EC:  BNZ   0106
....................                {
....................                   while(input(Pausa))
00EE:  BSF    F92.1
00F0:  BTFSS  F80.1
00F2:  BRA    0100
....................                      displays(j,i);
00F4:  MOVFF  0F,12
00F8:  MOVFF  0E,13
00FC:  RCALL  002E
00FE:  BRA    00EE
....................                      
....................                   B = 1;
0100:  MOVLW  01
0102:  MOVWF  11
....................                }
0104:  BRA    0124
....................                else if(input(Pausa) && B) // B es 1 (Ya se pauso anteriormente) 
0106:  BSF    F92.1
0108:  BTFSS  F80.1
010A:  BRA    0124
010C:  MOVF   11,F
010E:  BZ    0124
....................                {
....................                   while(input(Pausa))
0110:  BSF    F92.1
0112:  BTFSS  F80.1
0114:  BRA    0122
....................                      displays(j,i);
0116:  MOVFF  0F,12
011A:  MOVFF  0E,13
011E:  RCALL  002E
0120:  BRA    0110
....................                      
....................                   B = 0;
0122:  CLRF   11
....................                }
....................                
....................                if(input(Reinicio))
0124:  BSF    F92.2
0126:  BTFSS  F80.2
0128:  BRA    012C
....................                   goto loop;
012A:  BRA    00BA
012C:  INCF   10,F
012E:  MOVLB  0
0130:  BRA    00CE
....................             }
0132:  INCF   0E,F
0134:  BRA    00C6
0136:  INCF   0F,F
0138:  BRA    00BE
....................          }
013A:  MOVLB  0
013C:  BRA    00BA
....................       
....................       /*if(input(pin_a0))
....................       {
....................          while(input(pin_a0))
....................          {
....................             displays(j,i);
....................          }
....................          
....................          if(i<9)
....................             i++;
....................          else
....................          {
....................             if(j<9)
....................                j++;
....................             else
....................                j=0;
....................                
....................             i=0;
....................          }
....................       }
....................       else
....................          displays(j,i); //Contador manual con decenas*/
....................       
....................       /*if(input(pin_a0))
....................       {
....................          while(input(pin_a0));
....................          if(i < 9)
....................             i++;
....................          else
....................             i= 0;
....................       }
....................       else
....................          output_d(vec_c[i]);*/ // Aumentar 1 display con boton
....................       
....................       /*for(i=0;i<10;i++)
....................       {
....................          output_d(vec_c[i]);
....................          delay_ms(500);
....................       }*/ // Contar del 0 al 9
....................    }
.................... }
.................... 
013E:  SLEEP 
.................... void displays(int d, int u) // Imprime las unidades y decentas en 20 ms
.................... {
....................    output_high(Display2);
*
002E:  BCF    F92.4
0030:  BSF    F89.4
....................    output_low(Display1); // Prendemos D1
0032:  BCF    F92.3
0034:  BCF    F89.3
....................    output_d(vec_c[d]); // Mandamos decenas a D1
0036:  CLRF   03
0038:  MOVF   12,W
003A:  ADDLW  04
003C:  MOVWF  FE9
003E:  MOVLW  00
0040:  ADDWFC 03,W
0042:  MOVWF  FEA
0044:  MOVFF  FEF,F8C
0048:  CLRF   F95
....................    delay_ms(10);
004A:  MOVLW  0A
004C:  MOVWF  14
004E:  RCALL  0004
....................    output_high(Display1);
0050:  BCF    F92.3
0052:  BSF    F89.3
....................    output_low(Display2); // Prendemos D2
0054:  BCF    F92.4
0056:  BCF    F89.4
....................    output_d(vec_c[u]); // Mandamos unidades a D2
0058:  CLRF   03
005A:  MOVF   13,W
005C:  ADDLW  04
005E:  MOVWF  FE9
0060:  MOVLW  00
0062:  ADDWFC 03,W
0064:  MOVWF  FEA
0066:  MOVFF  FEF,F8C
006A:  CLRF   F95
....................    delay_ms(10);
006C:  MOVLW  0A
006E:  MOVWF  14
0070:  RCALL  0004
0072:  RETURN 0
....................    
.................... }

Configuration Fuses:
   Word  1: C920   PLL1 CPUDIV1 USBDIV INTRC FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
