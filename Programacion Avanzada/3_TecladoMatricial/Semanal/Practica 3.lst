CCS PCH C Compiler, Version 5.112, 29001               01-sep.-23 17:16

               Filename:   C:\Users\diego\Desktop\Programacion Avanzada\Practicas\Practica 3\En clase\Practica 3.lst

               ROM used:   426 bytes (1%)
                           Largest free fragment is 32342
               RAM used:   16 (1%) at main() level
                           20 (1%) worst case
               Stack used: 1 locations
               Stack size: 31

*
0000:  GOTO   00FA
.................... #include <18f4550.h>   // Libreria del Microcontrolador
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
.................... 
.................... #list
.................... 
.................... #fuses INTRC, NOWDT, NOPROTECT, NOLVP, CPUDIV1, PLL1, NOMCLR // Fusibles (Configuraciones del microcontrolador)
.................... #use delay(clock = 8M)  // 4M es 4 millones. Establecemos la velocidad va a operar el micro
*
008C:  CLRF   FEA
008E:  MOVLW  12
0090:  MOVWF  FE9
0092:  MOVF   FEF,W
0094:  BZ    00B0
0096:  MOVLW  02
0098:  MOVWF  01
009A:  CLRF   00
009C:  DECFSZ 00,F
009E:  BRA    009C
00A0:  DECFSZ 01,F
00A2:  BRA    009A
00A4:  MOVLW  97
00A6:  MOVWF  00
00A8:  DECFSZ 00,F
00AA:  BRA    00A8
00AC:  DECFSZ FEF,F
00AE:  BRA    0096
00B0:  RETURN 0
.................... 
.................... #define Display1 pin_a1
.................... #define Display2 pin_a0
.................... 
.................... // Columna, Renglon. 4 de Entrada, 4 de Salida
.................... 
.................... void displays(int d, int u);
.................... int CHECK(int *i);
.................... 
.................... // int vec_c[10] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D,0x7D,0x07,0x7F,0x67}; // Catodo
.................... int vec_c[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90}; // Anodo
.................... 
.................... void main()
*
00FA:  CLRF   FF8
00FC:  BCF    FD0.7
00FE:  MOVLW  70
0100:  MOVWF  FD3
0102:  MOVF   FD3,W
0104:  MOVF   FC1,W
0106:  ANDLW  C0
0108:  IORLW  0F
010A:  MOVWF  FC1
010C:  MOVLW  07
010E:  MOVWF  FB4
0110:  MOVLW  C0
0112:  MOVWF  04
0114:  MOVLW  F9
0116:  MOVWF  05
0118:  MOVLW  A4
011A:  MOVWF  06
011C:  MOVLW  B0
011E:  MOVWF  07
0120:  MOVLW  99
0122:  MOVWF  08
0124:  MOVLW  92
0126:  MOVWF  09
0128:  MOVLW  82
012A:  MOVWF  0A
012C:  MOVLW  F8
012E:  MOVWF  0B
0130:  MOVLW  80
0132:  MOVWF  0C
0134:  MOVLW  90
0136:  MOVWF  0D
0138:  CLRF   0E
013A:  CLRF   0F
.................... {
....................    int i = 0, j = 0;
....................    
....................    while(true)
....................    {  
....................       output_high(pin_b0);
013C:  BCF    F93.0
013E:  BSF    F8A.0
....................       if(CHECK(&i)) // Si se encontro columna presionada. Guardamos la fila que se activo
0140:  CLRF   11
0142:  MOVLW  0E
0144:  MOVWF  10
0146:  RCALL  0004
0148:  MOVF   01,F
014A:  BZ    0150
....................          j = 1;
014C:  MOVLW  01
014E:  MOVWF  0F
....................       output_low(pin_b0);   
0150:  BCF    F93.0
0152:  BCF    F8A.0
....................       
....................       output_high(pin_b1);
0154:  BCF    F93.1
0156:  BSF    F8A.1
....................       if(CHECK(&i)) // Si se encontro columna presionada
0158:  CLRF   11
015A:  MOVLW  0E
015C:  MOVWF  10
015E:  RCALL  0004
0160:  MOVF   01,F
0162:  BZ    0168
....................          j = 2;
0164:  MOVLW  02
0166:  MOVWF  0F
....................       output_low(pin_b1);
0168:  BCF    F93.1
016A:  BCF    F8A.1
....................       
....................       output_high(pin_b2);
016C:  BCF    F93.2
016E:  BSF    F8A.2
....................       if(CHECK(&i)) // Si se encontro columna presionada
0170:  CLRF   11
0172:  MOVLW  0E
0174:  MOVWF  10
0176:  RCALL  0004
0178:  MOVF   01,F
017A:  BZ    0180
....................          j = 3;
017C:  MOVLW  03
017E:  MOVWF  0F
....................       output_low(pin_b2);
0180:  BCF    F93.2
0182:  BCF    F8A.2
....................       
....................       output_high(pin_b3);
0184:  BCF    F93.3
0186:  BSF    F8A.3
....................       if(CHECK(&i)) // Si se encontro columna presionada
0188:  CLRF   11
018A:  MOVLW  0E
018C:  MOVWF  10
018E:  RCALL  0004
0190:  MOVF   01,F
0192:  BZ    0198
....................          j = 4;
0194:  MOVLW  04
0196:  MOVWF  0F
....................       output_low(pin_b3);
0198:  BCF    F93.3
019A:  BCF    F8A.3
....................       
....................       displays(i,j);
019C:  MOVFF  0E,10
01A0:  MOVFF  0F,11
01A4:  BRA    00B2
01A6:  BRA    013C
....................    }
.................... }
.................... 
01A8:  SLEEP 
.................... void displays(int d, int u) // Imprime las unidades y decentas en 20 ms
.................... {
....................    output_low(Display2);
*
00B2:  BCF    F92.0
00B4:  BCF    F89.0
....................    output_high(Display1); // Prendemos D1
00B6:  BCF    F92.1
00B8:  BSF    F89.1
....................    output_d(vec_c[d]); // Mandamos decenas a D1
00BA:  CLRF   03
00BC:  MOVF   10,W
00BE:  ADDLW  04
00C0:  MOVWF  FE9
00C2:  MOVLW  00
00C4:  ADDWFC 03,W
00C6:  MOVWF  FEA
00C8:  MOVFF  FEF,F8C
00CC:  CLRF   F95
....................    delay_ms(10);
00CE:  MOVLW  0A
00D0:  MOVWF  12
00D2:  RCALL  008C
....................    output_low(Display1);
00D4:  BCF    F92.1
00D6:  BCF    F89.1
....................    output_high(Display2); // Prendemos D2
00D8:  BCF    F92.0
00DA:  BSF    F89.0
....................    output_d(vec_c[u]); // Mandamos unidades a D2
00DC:  CLRF   03
00DE:  MOVF   11,W
00E0:  ADDLW  04
00E2:  MOVWF  FE9
00E4:  MOVLW  00
00E6:  ADDWFC 03,W
00E8:  MOVWF  FEA
00EA:  MOVFF  FEF,F8C
00EE:  CLRF   F95
....................    delay_ms(10);
00F0:  MOVLW  0A
00F2:  MOVWF  12
00F4:  RCALL  008C
00F6:  GOTO   01A6 (RETURN)
....................    
.................... }
.................... 
.................... int CHECK(*i) // Checa si alguna columna se presiono, pone su valor en i y devulve 1. Sino no modifica i y devuelve 0
.................... {
....................    if(input(pin_b4))
*
0004:  BSF    F93.4
0006:  BTFSS  F81.4
0008:  GOTO   0022
....................    {
....................       *i = 1;
000C:  MOVFF  10,FE9
0010:  MOVFF  11,FEA
0014:  MOVLW  01
0016:  MOVWF  FEF
....................       return 1;
0018:  MOVWF  01
001A:  GOTO   008A
....................    }
001E:  GOTO   008A
....................    else if(input(pin_b5))
0022:  BSF    F93.5
0024:  BTFSS  F81.5
0026:  GOTO   0042
....................    {
....................       *i = 2;
002A:  MOVFF  10,FE9
002E:  MOVFF  11,FEA
0032:  MOVLW  02
0034:  MOVWF  FEF
....................       return 1;
0036:  MOVLW  01
0038:  MOVWF  01
003A:  GOTO   008A
....................    }
003E:  GOTO   008A
....................    else if(input(pin_b6))
0042:  BSF    F93.6
0044:  BTFSS  F81.6
0046:  GOTO   0062
....................    {
....................       *i = 3;
004A:  MOVFF  10,FE9
004E:  MOVFF  11,FEA
0052:  MOVLW  03
0054:  MOVWF  FEF
....................       return 1;
0056:  MOVLW  01
0058:  MOVWF  01
005A:  GOTO   008A
....................    }
005E:  GOTO   008A
....................    else if(input(pin_b7))
0062:  BSF    F93.7
0064:  BTFSS  F81.7
0066:  GOTO   0082
....................    {
....................       *i = 4;
006A:  MOVFF  10,FE9
006E:  MOVFF  11,FEA
0072:  MOVLW  04
0074:  MOVWF  FEF
....................       return 1;
0076:  MOVLW  01
0078:  MOVWF  01
007A:  GOTO   008A
....................    }
007E:  GOTO   008A
....................    else
....................       return 0;
0082:  MOVLW  00
0084:  MOVWF  01
0086:  GOTO   008A
008A:  RETURN 0
.................... }

Configuration Fuses:
   Word  1: C920   PLL1 CPUDIV1 USBDIV INTRC FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
