CCS PCH C Compiler, Version 5.112, 29001               11-oct.-23 15:13

               Filename:   C:\Users\diego\Desktop\Programacion Avanzada\Practicas\Practica 7\Practica 7.lst

               ROM used:   8764 bytes (27%)
                           Largest free fragment is 24004
               RAM used:   41 (2%) at main() level
                           99 (5%) worst case
               Stack used: 4 locations
               Stack size: 31

*
0000:  GOTO   1D7C
.................... #include <18f4550.h>   // Libreria del Microcontrolador
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
0004:  MOVLW  8E
0006:  MOVWF  00
0008:  MOVF   4F,W
000A:  SUBWF  00,F
000C:  MOVFF  50,02
0010:  MOVFF  51,01
0014:  BSF    02.7
0016:  MOVF   00,F
0018:  BTFSC  FD8.2
001A:  GOTO   003A
001E:  BCF    FD8.0
0020:  MOVF   02,F
0022:  BTFSS  FD8.2
0024:  GOTO   0030
0028:  MOVF   01,F
002A:  BTFSC  FD8.2
002C:  GOTO   003A
0030:  RRCF   02,F
0032:  RRCF   01,F
0034:  DECFSZ 00,F
0036:  GOTO   001E
003A:  BTFSS  50.7
003C:  GOTO   004A
0040:  COMF   01,F
0042:  COMF   02,F
0044:  INCF   01,F
0046:  BTFSC  FD8.2
0048:  INCF   02,F
004A:  RETURN 0
004C:  MOVLW  8E
004E:  MOVWF  00
0050:  MOVFF  54,01
0054:  MOVFF  53,02
0058:  CLRF   03
005A:  MOVF   01,F
005C:  BNZ   0070
005E:  MOVFF  02,01
0062:  CLRF   02
0064:  MOVLW  08
0066:  SUBWF  00,F
0068:  MOVF   01,F
006A:  BNZ   0070
006C:  CLRF   00
006E:  BRA    0080
0070:  BCF    FD8.0
0072:  BTFSC  01.7
0074:  BRA    007E
0076:  RLCF   02,F
0078:  RLCF   01,F
007A:  DECF   00,F
007C:  BRA    0070
007E:  BCF    01.7
0080:  RETURN 0
0082:  MOVFF  50,57
0086:  MOVF   54,W
0088:  XORWF  57,F
008A:  BTFSS  57.7
008C:  BRA    0098
008E:  BCF    FD8.2
0090:  BCF    FD8.0
0092:  BTFSC  50.7
0094:  BSF    FD8.0
0096:  BRA    00F6
0098:  MOVFF  50,57
009C:  MOVFF  53,58
00A0:  MOVF   4F,W
00A2:  SUBWF  58,F
00A4:  BZ    00B2
00A6:  BTFSS  57.7
00A8:  BRA    00F6
00AA:  MOVF   FD8,W
00AC:  XORLW  01
00AE:  MOVWF  FD8
00B0:  BRA    00F6
00B2:  MOVFF  54,58
00B6:  MOVF   50,W
00B8:  SUBWF  58,F
00BA:  BZ    00C8
00BC:  BTFSS  57.7
00BE:  BRA    00F6
00C0:  MOVF   FD8,W
00C2:  XORLW  01
00C4:  MOVWF  FD8
00C6:  BRA    00F6
00C8:  MOVFF  55,58
00CC:  MOVF   51,W
00CE:  SUBWF  58,F
00D0:  BZ    00DE
00D2:  BTFSS  57.7
00D4:  BRA    00F6
00D6:  MOVF   FD8,W
00D8:  XORLW  01
00DA:  MOVWF  FD8
00DC:  BRA    00F6
00DE:  MOVFF  56,58
00E2:  MOVF   52,W
00E4:  SUBWF  58,F
00E6:  BZ    00F4
00E8:  BTFSS  57.7
00EA:  BRA    00F6
00EC:  MOVF   FD8,W
00EE:  XORLW  01
00F0:  MOVWF  FD8
00F2:  BRA    00F6
00F4:  BCF    FD8.0
00F6:  RETURN 0
00F8:  MOVF   48,W
00FA:  BTFSC  FD8.2
00FC:  BRA    0248
00FE:  MOVWF  54
0100:  MOVF   4C,W
0102:  BTFSC  FD8.2
0104:  BRA    0248
0106:  SUBWF  54,F
0108:  BNC   0114
010A:  MOVLW  7F
010C:  ADDWF  54,F
010E:  BTFSC  FD8.0
0110:  BRA    0248
0112:  BRA    0120
0114:  MOVLW  81
0116:  SUBWF  54,F
0118:  BTFSS  FD8.0
011A:  BRA    0248
011C:  BTFSC  FD8.2
011E:  BRA    0248
0120:  MOVFF  54,00
0124:  CLRF   01
0126:  CLRF   02
0128:  CLRF   03
012A:  CLRF   53
012C:  MOVFF  49,52
0130:  BSF    52.7
0132:  MOVFF  4A,51
0136:  MOVFF  4B,50
013A:  MOVLW  19
013C:  MOVWF  54
013E:  MOVF   4F,W
0140:  SUBWF  50,F
0142:  BC    015E
0144:  MOVLW  01
0146:  SUBWF  51,F
0148:  BC    015E
014A:  SUBWF  52,F
014C:  BC    015E
014E:  SUBWF  53,F
0150:  BC    015E
0152:  INCF   53,F
0154:  INCF   52,F
0156:  INCF   51,F
0158:  MOVF   4F,W
015A:  ADDWF  50,F
015C:  BRA    01AE
015E:  MOVF   4E,W
0160:  SUBWF  51,F
0162:  BC    0188
0164:  MOVLW  01
0166:  SUBWF  52,F
0168:  BC    0188
016A:  SUBWF  53,F
016C:  BC    0188
016E:  INCF   53,F
0170:  INCF   52,F
0172:  MOVF   4E,W
0174:  ADDWF  51,F
0176:  MOVF   4F,W
0178:  ADDWF  50,F
017A:  BNC   01AE
017C:  INCF   51,F
017E:  BNZ   01AE
0180:  INCF   52,F
0182:  BNZ   01AE
0184:  INCF   53,F
0186:  BRA    01AE
0188:  MOVF   4D,W
018A:  IORLW  80
018C:  SUBWF  52,F
018E:  BC    01AC
0190:  MOVLW  01
0192:  SUBWF  53,F
0194:  BC    01AC
0196:  INCF   53,F
0198:  MOVF   4D,W
019A:  IORLW  80
019C:  ADDWF  52,F
019E:  MOVF   4E,W
01A0:  ADDWF  51,F
01A2:  BNC   0176
01A4:  INCF   52,F
01A6:  BNZ   0176
01A8:  INCF   53,F
01AA:  BRA    0176
01AC:  BSF    03.0
01AE:  DECFSZ 54,F
01B0:  BRA    01B4
01B2:  BRA    01CA
01B4:  BCF    FD8.0
01B6:  RLCF   50,F
01B8:  RLCF   51,F
01BA:  RLCF   52,F
01BC:  RLCF   53,F
01BE:  BCF    FD8.0
01C0:  RLCF   03,F
01C2:  RLCF   02,F
01C4:  RLCF   01,F
01C6:  RLCF   55,F
01C8:  BRA    013E
01CA:  BTFSS  55.0
01CC:  BRA    01DA
01CE:  BCF    FD8.0
01D0:  RRCF   01,F
01D2:  RRCF   02,F
01D4:  RRCF   03,F
01D6:  RRCF   55,F
01D8:  BRA    01DE
01DA:  DECF   00,F
01DC:  BZ    0248
01DE:  BTFSC  55.7
01E0:  BRA    021E
01E2:  BCF    FD8.0
01E4:  RLCF   50,F
01E6:  RLCF   51,F
01E8:  RLCF   52,F
01EA:  RLCF   53,F
01EC:  MOVF   4F,W
01EE:  SUBWF  50,F
01F0:  BC    0200
01F2:  MOVLW  01
01F4:  SUBWF  51,F
01F6:  BC    0200
01F8:  SUBWF  52,F
01FA:  BC    0200
01FC:  SUBWF  53,F
01FE:  BNC   0234
0200:  MOVF   4E,W
0202:  SUBWF  51,F
0204:  BC    0210
0206:  MOVLW  01
0208:  SUBWF  52,F
020A:  BC    0210
020C:  SUBWF  53,F
020E:  BNC   0234
0210:  MOVF   4D,W
0212:  IORLW  80
0214:  SUBWF  52,F
0216:  BC    021E
0218:  MOVLW  01
021A:  SUBWF  53,F
021C:  BNC   0234
021E:  INCF   03,F
0220:  BNZ   0234
0222:  INCF   02,F
0224:  BNZ   0234
0226:  INCF   01,F
0228:  BNZ   0234
022A:  INCF   00,F
022C:  BZ    0248
022E:  RRCF   01,F
0230:  RRCF   02,F
0232:  RRCF   03,F
0234:  MOVFF  49,54
0238:  MOVF   4D,W
023A:  XORWF  54,F
023C:  BTFSS  54.7
023E:  BRA    0244
0240:  BSF    01.7
0242:  BRA    0250
0244:  BCF    01.7
0246:  BRA    0250
0248:  CLRF   00
024A:  CLRF   01
024C:  CLRF   02
024E:  CLRF   03
0250:  RETURN 0
0252:  MOVF   4F,W
0254:  BTFSC  FD8.2
0256:  BRA    033A
0258:  MOVWF  00
025A:  MOVF   53,W
025C:  BTFSC  FD8.2
025E:  BRA    033A
0260:  ADDWF  00,F
0262:  BNC   026C
0264:  MOVLW  81
0266:  ADDWF  00,F
0268:  BC    033A
026A:  BRA    0274
026C:  MOVLW  7F
026E:  SUBWF  00,F
0270:  BNC   033A
0272:  BZ    033A
0274:  MOVFF  50,57
0278:  MOVF   54,W
027A:  XORWF  57,F
027C:  BSF    50.7
027E:  BSF    54.7
0280:  MOVF   52,W
0282:  MULWF  56
0284:  MOVFF  FF4,59
0288:  MOVF   51,W
028A:  MULWF  55
028C:  MOVFF  FF4,03
0290:  MOVFF  FF3,58
0294:  MULWF  56
0296:  MOVF   FF3,W
0298:  ADDWF  59,F
029A:  MOVF   FF4,W
029C:  ADDWFC 58,F
029E:  MOVLW  00
02A0:  ADDWFC 03,F
02A2:  MOVF   52,W
02A4:  MULWF  55
02A6:  MOVF   FF3,W
02A8:  ADDWF  59,F
02AA:  MOVF   FF4,W
02AC:  ADDWFC 58,F
02AE:  MOVLW  00
02B0:  CLRF   02
02B2:  ADDWFC 03,F
02B4:  ADDWFC 02,F
02B6:  MOVF   50,W
02B8:  MULWF  56
02BA:  MOVF   FF3,W
02BC:  ADDWF  58,F
02BE:  MOVF   FF4,W
02C0:  ADDWFC 03,F
02C2:  MOVLW  00
02C4:  ADDWFC 02,F
02C6:  MOVF   50,W
02C8:  MULWF  55
02CA:  MOVF   FF3,W
02CC:  ADDWF  03,F
02CE:  MOVF   FF4,W
02D0:  ADDWFC 02,F
02D2:  MOVLW  00
02D4:  CLRF   01
02D6:  ADDWFC 01,F
02D8:  MOVF   52,W
02DA:  MULWF  54
02DC:  MOVF   FF3,W
02DE:  ADDWF  58,F
02E0:  MOVF   FF4,W
02E2:  ADDWFC 03,F
02E4:  MOVLW  00
02E6:  ADDWFC 02,F
02E8:  ADDWFC 01,F
02EA:  MOVF   51,W
02EC:  MULWF  54
02EE:  MOVF   FF3,W
02F0:  ADDWF  03,F
02F2:  MOVF   FF4,W
02F4:  ADDWFC 02,F
02F6:  MOVLW  00
02F8:  ADDWFC 01,F
02FA:  MOVF   50,W
02FC:  MULWF  54
02FE:  MOVF   FF3,W
0300:  ADDWF  02,F
0302:  MOVF   FF4,W
0304:  ADDWFC 01,F
0306:  INCF   00,F
0308:  BTFSC  01.7
030A:  BRA    0316
030C:  RLCF   58,F
030E:  RLCF   03,F
0310:  RLCF   02,F
0312:  RLCF   01,F
0314:  DECF   00,F
0316:  MOVLW  00
0318:  BTFSS  58.7
031A:  BRA    0330
031C:  INCF   03,F
031E:  ADDWFC 02,F
0320:  ADDWFC 01,F
0322:  MOVF   01,W
0324:  BNZ   0330
0326:  MOVF   02,W
0328:  BNZ   0330
032A:  MOVF   03,W
032C:  BNZ   0330
032E:  INCF   00,F
0330:  BTFSC  57.7
0332:  BSF    01.7
0334:  BTFSS  57.7
0336:  BCF    01.7
0338:  BRA    0342
033A:  CLRF   00
033C:  CLRF   01
033E:  CLRF   02
0340:  CLRF   03
0342:  RETURN 0
0344:  MOVLW  80
0346:  BTFSC  FD8.1
0348:  XORWF  58,F
034A:  CLRF   5D
034C:  CLRF   5E
034E:  MOVFF  54,5C
0352:  MOVF   58,W
0354:  XORWF  5C,F
0356:  MOVF   53,W
0358:  BTFSC  FD8.2
035A:  BRA    0514
035C:  MOVWF  5B
035E:  MOVWF  00
0360:  MOVF   57,W
0362:  BTFSC  FD8.2
0364:  BRA    0526
0366:  SUBWF  5B,F
0368:  BTFSC  FD8.2
036A:  BRA    046E
036C:  BNC   03E8
036E:  MOVFF  58,61
0372:  BSF    x61.7
0374:  MOVFF  59,60
0378:  MOVFF  5A,5F
037C:  CLRF   5E
037E:  BCF    FD8.0
0380:  RRCF   x61,F
0382:  RRCF   x60,F
0384:  RRCF   5F,F
0386:  RRCF   5E,F
0388:  DECFSZ 5B,F
038A:  BRA    037C
038C:  BTFSS  5C.7
038E:  BRA    0396
0390:  BSF    5D.0
0392:  BRA    054E
0394:  BCF    5D.0
0396:  BCF    5B.0
0398:  BSF    5D.4
039A:  CLRF   FEA
039C:  MOVLW  56
039E:  MOVWF  FE9
03A0:  BRA    0574
03A2:  BCF    5D.4
03A4:  BTFSC  5C.7
03A6:  BRA    03BC
03A8:  BTFSS  5B.0
03AA:  BRA    03D2
03AC:  RRCF   x61,F
03AE:  RRCF   x60,F
03B0:  RRCF   5F,F
03B2:  RRCF   5E,F
03B4:  INCF   00,F
03B6:  BTFSC  FD8.2
03B8:  BRA    0544
03BA:  BRA    03D2
03BC:  BTFSC  x61.7
03BE:  BRA    03D8
03C0:  BCF    FD8.0
03C2:  RLCF   5E,F
03C4:  RLCF   5F,F
03C6:  RLCF   x60,F
03C8:  RLCF   x61,F
03CA:  DECF   00,F
03CC:  BTFSC  FD8.2
03CE:  BRA    0544
03D0:  BRA    03BC
03D2:  BSF    5D.6
03D4:  BRA    04AC
03D6:  BCF    5D.6
03D8:  MOVFF  54,5C
03DC:  BTFSS  54.7
03DE:  BRA    03E4
03E0:  BSF    x61.7
03E2:  BRA    0536
03E4:  BCF    x61.7
03E6:  BRA    0536
03E8:  MOVFF  57,5B
03EC:  MOVFF  57,00
03F0:  MOVF   53,W
03F2:  SUBWF  5B,F
03F4:  MOVFF  54,61
03F8:  BSF    x61.7
03FA:  MOVFF  55,60
03FE:  MOVFF  56,5F
0402:  CLRF   5E
0404:  BCF    FD8.0
0406:  RRCF   x61,F
0408:  RRCF   x60,F
040A:  RRCF   5F,F
040C:  RRCF   5E,F
040E:  DECFSZ 5B,F
0410:  BRA    0402
0412:  BTFSS  5C.7
0414:  BRA    041C
0416:  BSF    5D.1
0418:  BRA    054E
041A:  BCF    5D.1
041C:  BCF    5B.0
041E:  BSF    5D.5
0420:  CLRF   FEA
0422:  MOVLW  5A
0424:  MOVWF  FE9
0426:  BRA    0574
0428:  BCF    5D.5
042A:  BTFSC  5C.7
042C:  BRA    0442
042E:  BTFSS  5B.0
0430:  BRA    0458
0432:  RRCF   x61,F
0434:  RRCF   x60,F
0436:  RRCF   5F,F
0438:  RRCF   5E,F
043A:  INCF   00,F
043C:  BTFSC  FD8.2
043E:  BRA    0544
0440:  BRA    0458
0442:  BTFSC  x61.7
0444:  BRA    045E
0446:  BCF    FD8.0
0448:  RLCF   5E,F
044A:  RLCF   5F,F
044C:  RLCF   x60,F
044E:  RLCF   x61,F
0450:  DECF   00,F
0452:  BTFSC  FD8.2
0454:  BRA    0544
0456:  BRA    0442
0458:  BSF    5D.7
045A:  BRA    04AC
045C:  BCF    5D.7
045E:  MOVFF  58,5C
0462:  BTFSS  58.7
0464:  BRA    046A
0466:  BSF    x61.7
0468:  BRA    0536
046A:  BCF    x61.7
046C:  BRA    0536
046E:  MOVFF  58,61
0472:  BSF    x61.7
0474:  MOVFF  59,60
0478:  MOVFF  5A,5F
047C:  BTFSS  5C.7
047E:  BRA    0488
0480:  BCF    x61.7
0482:  BSF    5D.2
0484:  BRA    054E
0486:  BCF    5D.2
0488:  CLRF   5E
048A:  BCF    5B.0
048C:  CLRF   FEA
048E:  MOVLW  56
0490:  MOVWF  FE9
0492:  BRA    0574
0494:  BTFSC  5C.7
0496:  BRA    04D0
0498:  MOVFF  54,5C
049C:  BTFSS  5B.0
049E:  BRA    04AC
04A0:  RRCF   x61,F
04A2:  RRCF   x60,F
04A4:  RRCF   5F,F
04A6:  RRCF   5E,F
04A8:  INCF   00,F
04AA:  BZ    0544
04AC:  BTFSS  5E.7
04AE:  BRA    04C6
04B0:  INCF   5F,F
04B2:  BNZ   04C6
04B4:  INCF   x60,F
04B6:  BNZ   04C6
04B8:  INCF   x61,F
04BA:  BNZ   04C6
04BC:  RRCF   x61,F
04BE:  RRCF   x60,F
04C0:  RRCF   5F,F
04C2:  INCF   00,F
04C4:  BZ    0544
04C6:  BTFSC  5D.6
04C8:  BRA    03D6
04CA:  BTFSC  5D.7
04CC:  BRA    045C
04CE:  BRA    0508
04D0:  MOVLW  80
04D2:  XORWF  x61,F
04D4:  BTFSS  x61.7
04D6:  BRA    04E0
04D8:  BRA    054E
04DA:  MOVFF  58,5C
04DE:  BRA    04F4
04E0:  MOVFF  54,5C
04E4:  MOVF   x61,F
04E6:  BNZ   04F4
04E8:  MOVF   x60,F
04EA:  BNZ   04F4
04EC:  MOVF   5F,F
04EE:  BNZ   04F4
04F0:  CLRF   00
04F2:  BRA    0536
04F4:  BTFSC  x61.7
04F6:  BRA    0508
04F8:  BCF    FD8.0
04FA:  RLCF   5E,F
04FC:  RLCF   5F,F
04FE:  RLCF   x60,F
0500:  RLCF   x61,F
0502:  DECFSZ 00,F
0504:  BRA    04F4
0506:  BRA    0544
0508:  BTFSS  5C.7
050A:  BRA    0510
050C:  BSF    x61.7
050E:  BRA    0536
0510:  BCF    x61.7
0512:  BRA    0536
0514:  MOVFF  57,00
0518:  MOVFF  58,61
051C:  MOVFF  59,60
0520:  MOVFF  5A,5F
0524:  BRA    0536
0526:  MOVFF  53,00
052A:  MOVFF  54,61
052E:  MOVFF  55,60
0532:  MOVFF  56,5F
0536:  MOVFF  61,01
053A:  MOVFF  60,02
053E:  MOVFF  5F,03
0542:  BRA    05AC
0544:  CLRF   00
0546:  CLRF   01
0548:  CLRF   02
054A:  CLRF   03
054C:  BRA    05AC
054E:  CLRF   5E
0550:  COMF   5F,F
0552:  COMF   x60,F
0554:  COMF   x61,F
0556:  COMF   5E,F
0558:  INCF   5E,F
055A:  BNZ   0566
055C:  INCF   5F,F
055E:  BNZ   0566
0560:  INCF   x60,F
0562:  BNZ   0566
0564:  INCF   x61,F
0566:  BTFSC  5D.0
0568:  BRA    0394
056A:  BTFSC  5D.1
056C:  BRA    041A
056E:  BTFSC  5D.2
0570:  BRA    0486
0572:  BRA    04DA
0574:  MOVF   FEF,W
0576:  ADDWF  5F,F
0578:  BNC   0584
057A:  INCF   x60,F
057C:  BNZ   0584
057E:  INCF   x61,F
0580:  BTFSC  FD8.2
0582:  BSF    5B.0
0584:  MOVF   FED,F
0586:  MOVF   FEF,W
0588:  ADDWF  x60,F
058A:  BNC   0592
058C:  INCF   x61,F
058E:  BTFSC  FD8.2
0590:  BSF    5B.0
0592:  MOVF   FED,F
0594:  MOVF   FEF,W
0596:  BTFSC  FEF.7
0598:  BRA    059C
059A:  XORLW  80
059C:  ADDWF  x61,F
059E:  BTFSC  FD8.0
05A0:  BSF    5B.0
05A2:  BTFSC  5D.4
05A4:  BRA    03A2
05A6:  BTFSC  5D.5
05A8:  BRA    0428
05AA:  BRA    0494
05AC:  RETURN 0
*
0A52:  MOVLW  8E
0A54:  MOVWF  00
0A56:  MOVFF  46,01
0A5A:  MOVFF  45,02
0A5E:  CLRF   03
0A60:  BTFSS  46.7
0A62:  BRA    0A6E
0A64:  COMF   01,F
0A66:  COMF   02,F
0A68:  INCF   02,F
0A6A:  BNZ   0A6E
0A6C:  INCF   01,F
0A6E:  MOVF   01,F
0A70:  BNZ   0A84
0A72:  MOVFF  02,01
0A76:  CLRF   02
0A78:  MOVLW  08
0A7A:  SUBWF  00,F
0A7C:  MOVF   01,F
0A7E:  BNZ   0A84
0A80:  CLRF   00
0A82:  BRA    0A98
0A84:  BCF    FD8.0
0A86:  BTFSC  01.7
0A88:  BRA    0A92
0A8A:  RLCF   02,F
0A8C:  RLCF   01,F
0A8E:  DECF   00,F
0A90:  BRA    0A84
0A92:  BTFSC  46.7
0A94:  BRA    0A98
0A96:  BCF    01.7
0A98:  RETURN 0
*
1484:  CLRF   01
1486:  CLRF   02
1488:  CLRF   00
148A:  CLRF   03
148C:  MOVF   43,W
148E:  BNZ   1494
1490:  MOVF   42,W
1492:  BZ    14C4
1494:  MOVLW  10
1496:  MOVWF  44
1498:  BCF    FD8.0
149A:  RLCF   40,F
149C:  RLCF   41,F
149E:  RLCF   00,F
14A0:  RLCF   03,F
14A2:  MOVF   43,W
14A4:  SUBWF  03,W
14A6:  BNZ   14AC
14A8:  MOVF   42,W
14AA:  SUBWF  00,W
14AC:  BNC   14BC
14AE:  MOVF   42,W
14B0:  SUBWF  00,F
14B2:  BTFSS  FD8.0
14B4:  DECF   03,F
14B6:  MOVF   43,W
14B8:  SUBWF  03,F
14BA:  BSF    FD8.0
14BC:  RLCF   01,F
14BE:  RLCF   02,F
14C0:  DECFSZ 44,F
14C2:  BRA    1498
14C4:  RETURN 0
14C6:  MOVF   3F,W
14C8:  MULWF  41
14CA:  MOVFF  FF3,01
14CE:  MOVFF  FF4,00
14D2:  MULWF  42
14D4:  MOVF   FF3,W
14D6:  ADDWF  00,F
14D8:  MOVF   40,W
14DA:  MULWF  41
14DC:  MOVF   FF3,W
14DE:  ADDWFC 00,W
14E0:  MOVWF  02
14E2:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device adc = 10 // Resolucion del ADC en bits
.................... #fuses XT, NOWDT, NOPROTECT, NOLVP, CPUDIV1, PLL1 // Fusibles (Configuraciones del microcontrolador)
.................... #use delay(clock = 4M)
*
1ADE:  CLRF   FEA
1AE0:  MOVLW  26
1AE2:  MOVWF  FE9
1AE4:  MOVF   FEF,W
1AE6:  BZ    1B04
1AE8:  MOVLW  01
1AEA:  MOVWF  01
1AEC:  CLRF   00
1AEE:  DECFSZ 00,F
1AF0:  BRA    1AEE
1AF2:  DECFSZ 01,F
1AF4:  BRA    1AEC
1AF6:  MOVLW  4A
1AF8:  MOVWF  00
1AFA:  DECFSZ 00,F
1AFC:  BRA    1AFA
1AFE:  BRA    1B00
1B00:  DECFSZ FEF,F
1B02:  BRA    1AE8
1B04:  RETURN 0
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
05AE:  BCF    4E.0
....................    y = x;
05B0:  MOVFF  42,47
05B4:  MOVFF  41,46
05B8:  MOVFF  40,45
05BC:  MOVFF  3F,44
.................... 
....................    if (x < 0)
05C0:  MOVFF  42,52
05C4:  MOVFF  41,51
05C8:  MOVFF  40,50
05CC:  MOVFF  3F,4F
05D0:  CLRF   56
05D2:  CLRF   55
05D4:  CLRF   54
05D6:  CLRF   53
05D8:  RCALL  0082
05DA:  BNC   05E4
....................    {
....................       s = 1;
05DC:  BSF    4E.0
....................       y = -y;
05DE:  MOVF   45,W
05E0:  XORLW  80
05E2:  MOVWF  45
....................    }
.................... 
....................    if (y <= 32768.0)
05E4:  MOVFF  47,52
05E8:  MOVFF  46,51
05EC:  MOVFF  45,50
05F0:  MOVFF  44,4F
05F4:  CLRF   56
05F6:  CLRF   55
05F8:  CLRF   54
05FA:  MOVLW  8E
05FC:  MOVWF  53
05FE:  RCALL  0082
0600:  BC    0604
0602:  BNZ   0632
....................       res = (float32)(unsigned int16)y;
0604:  MOVFF  47,52
0608:  MOVFF  46,51
060C:  MOVFF  45,50
0610:  MOVFF  44,4F
0614:  RCALL  0004
0616:  MOVFF  02,54
061A:  MOVFF  01,53
061E:  RCALL  004C
0620:  MOVFF  03,4B
0624:  MOVFF  02,4A
0628:  MOVFF  01,49
062C:  MOVFF  00,48
0630:  BRA    07AC
.................... 
....................  else if (y < 10000000.0)
0632:  MOVFF  47,52
0636:  MOVFF  46,51
063A:  MOVFF  45,50
063E:  MOVFF  44,4F
0642:  MOVLW  80
0644:  MOVWF  56
0646:  MOVLW  96
0648:  MOVWF  55
064A:  MOVLW  18
064C:  MOVWF  54
064E:  MOVLW  96
0650:  MOVWF  53
0652:  RCALL  0082
0654:  BTFSS  FD8.0
0656:  BRA    079C
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
0658:  MOVFF  47,52
065C:  MOVFF  46,51
0660:  MOVFF  45,50
0664:  MOVFF  44,4F
0668:  CLRF   56
066A:  CLRF   55
066C:  CLRF   54
066E:  MOVLW  70
0670:  MOVWF  53
0672:  RCALL  0252
0674:  MOVFF  03,52
0678:  MOVFF  02,51
067C:  MOVFF  01,50
0680:  MOVFF  00,4F
0684:  RCALL  0004
0686:  MOVFF  02,4D
068A:  MOVFF  01,4C
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
068E:  MOVFF  47,52
0692:  MOVFF  46,51
0696:  MOVFF  45,50
069A:  MOVFF  44,4F
069E:  CLRF   56
06A0:  CLRF   55
06A2:  CLRF   54
06A4:  MOVLW  70
06A6:  MOVWF  53
06A8:  RCALL  0252
06AA:  MOVFF  03,52
06AE:  MOVFF  02,51
06B2:  MOVFF  01,50
06B6:  MOVFF  00,4F
06BA:  MOVFF  4D,54
06BE:  MOVFF  4C,53
06C2:  RCALL  004C
06C4:  BSF    FD8.1
06C6:  MOVFF  52,56
06CA:  MOVFF  51,55
06CE:  MOVFF  50,54
06D2:  MOVFF  4F,53
06D6:  MOVFF  03,5A
06DA:  MOVFF  02,59
06DE:  MOVFF  01,58
06E2:  MOVFF  00,57
06E6:  RCALL  0344
06E8:  CLRF   52
06EA:  CLRF   51
06EC:  CLRF   50
06EE:  MOVLW  8E
06F0:  MOVWF  4F
06F2:  MOVFF  03,56
06F6:  MOVFF  02,55
06FA:  MOVFF  01,54
06FE:  MOVFF  00,53
0702:  RCALL  0252
0704:  MOVFF  03,47
0708:  MOVFF  02,46
070C:  MOVFF  01,45
0710:  MOVFF  00,44
....................       res = 32768.0*(float32)l;
0714:  MOVFF  4D,54
0718:  MOVFF  4C,53
071C:  RCALL  004C
071E:  CLRF   52
0720:  CLRF   51
0722:  CLRF   50
0724:  MOVLW  8E
0726:  MOVWF  4F
0728:  MOVFF  03,56
072C:  MOVFF  02,55
0730:  MOVFF  01,54
0734:  MOVFF  00,53
0738:  RCALL  0252
073A:  MOVFF  03,4B
073E:  MOVFF  02,4A
0742:  MOVFF  01,49
0746:  MOVFF  00,48
....................       res += (float32)(unsigned int16)y;
074A:  MOVFF  47,52
074E:  MOVFF  46,51
0752:  MOVFF  45,50
0756:  MOVFF  44,4F
075A:  RCALL  0004
075C:  MOVFF  02,54
0760:  MOVFF  01,53
0764:  RCALL  004C
0766:  BCF    FD8.1
0768:  MOVFF  4B,56
076C:  MOVFF  4A,55
0770:  MOVFF  49,54
0774:  MOVFF  48,53
0778:  MOVFF  03,5A
077C:  MOVFF  02,59
0780:  MOVFF  01,58
0784:  MOVFF  00,57
0788:  RCALL  0344
078A:  MOVFF  03,4B
078E:  MOVFF  02,4A
0792:  MOVFF  01,49
0796:  MOVFF  00,48
....................    }
079A:  BRA    07AC
.................... 
....................  else
....................   res = y;
079C:  MOVFF  47,4B
07A0:  MOVFF  46,4A
07A4:  MOVFF  45,49
07A8:  MOVFF  44,48
.................... 
....................  y = y - (float32)(unsigned int16)y;
07AC:  MOVFF  47,52
07B0:  MOVFF  46,51
07B4:  MOVFF  45,50
07B8:  MOVFF  44,4F
07BC:  RCALL  0004
07BE:  MOVFF  02,54
07C2:  MOVFF  01,53
07C6:  RCALL  004C
07C8:  BSF    FD8.1
07CA:  MOVFF  47,56
07CE:  MOVFF  46,55
07D2:  MOVFF  45,54
07D6:  MOVFF  44,53
07DA:  MOVFF  03,5A
07DE:  MOVFF  02,59
07E2:  MOVFF  01,58
07E6:  MOVFF  00,57
07EA:  RCALL  0344
07EC:  MOVFF  03,47
07F0:  MOVFF  02,46
07F4:  MOVFF  01,45
07F8:  MOVFF  00,44
.................... 
....................  if (s)
07FC:  BTFSS  4E.0
07FE:  BRA    0806
....................   res = -res;
0800:  MOVF   49,W
0802:  XORLW  80
0804:  MOVWF  49
.................... 
....................  if (y != 0)
0806:  MOVFF  47,52
080A:  MOVFF  46,51
080E:  MOVFF  45,50
0812:  MOVFF  44,4F
0816:  CLRF   56
0818:  CLRF   55
081A:  CLRF   54
081C:  CLRF   53
081E:  RCALL  0082
0820:  BZ    088E
....................  {
....................   if (s == 1 && n == 0)
0822:  BTFSS  4E.0
0824:  BRA    0858
0826:  MOVF   43,F
0828:  BNZ   0858
....................    res -= 1.0;
082A:  BSF    FD8.1
082C:  MOVFF  4B,56
0830:  MOVFF  4A,55
0834:  MOVFF  49,54
0838:  MOVFF  48,53
083C:  CLRF   5A
083E:  CLRF   59
0840:  CLRF   58
0842:  MOVLW  7F
0844:  MOVWF  57
0846:  RCALL  0344
0848:  MOVFF  03,4B
084C:  MOVFF  02,4A
0850:  MOVFF  01,49
0854:  MOVFF  00,48
.................... 
....................   if (s == 0 && n == 1)
0858:  BTFSC  4E.0
085A:  BRA    088E
085C:  DECFSZ 43,W
085E:  BRA    088E
....................    res += 1.0;
0860:  BCF    FD8.1
0862:  MOVFF  4B,56
0866:  MOVFF  4A,55
086A:  MOVFF  49,54
086E:  MOVFF  48,53
0872:  CLRF   5A
0874:  CLRF   59
0876:  CLRF   58
0878:  MOVLW  7F
087A:  MOVWF  57
087C:  RCALL  0344
087E:  MOVFF  03,4B
0882:  MOVFF  02,4A
0886:  MOVFF  01,49
088A:  MOVFF  00,48
....................  }
....................  if (x == 0)
088E:  MOVFF  42,52
0892:  MOVFF  41,51
0896:  MOVFF  40,50
089A:  MOVFF  3F,4F
089E:  CLRF   56
08A0:  CLRF   55
08A2:  CLRF   54
08A4:  CLRF   53
08A6:  CALL   0082
08AA:  BNZ   08B4
....................     res = 0;
08AC:  CLRF   4B
08AE:  CLRF   4A
08B0:  CLRF   49
08B2:  CLRF   48
.................... 
....................  return (res);
08B4:  MOVFF  48,00
08B8:  MOVFF  49,01
08BC:  MOVFF  4A,02
08C0:  MOVFF  4B,03
08C4:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
08E0:  MOVFF  3E,42
08E4:  MOVFF  3D,41
08E8:  MOVFF  3C,40
08EC:  MOVFF  3B,3F
08F0:  CLRF   43
08F2:  RCALL  05AE
08F4:  GOTO   09F8 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
08C6:  MOVFF  3E,42
08CA:  MOVFF  3D,41
08CE:  MOVFF  3C,40
08D2:  MOVFF  3B,3F
08D6:  MOVLW  01
08D8:  MOVWF  43
08DA:  RCALL  05AE
08DC:  GOTO   09B0 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
08F8:  MOVFF  32,52
08FC:  MOVFF  31,51
0900:  MOVFF  30,50
0904:  MOVFF  2F,4F
0908:  CLRF   56
090A:  CLRF   55
090C:  CLRF   54
090E:  CLRF   53
0910:  CALL   0082
0914:  BTFSC  FD8.2
0916:  BRA    0A50
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
0918:  MOVFF  2E,4B
091C:  MOVFF  2D,4A
0920:  MOVFF  2C,49
0924:  MOVFF  2B,48
0928:  MOVFF  32,4F
092C:  MOVFF  31,4E
0930:  MOVFF  30,4D
0934:  MOVFF  2F,4C
0938:  CALL   00F8
093C:  MOVFF  03,3A
0940:  MOVFF  02,39
0944:  MOVFF  01,38
0948:  MOVFF  00,37
094C:  MOVFF  03,52
0950:  MOVFF  02,51
0954:  MOVFF  01,50
0958:  MOVFF  00,4F
095C:  CLRF   56
095E:  CLRF   55
0960:  CLRF   54
0962:  CLRF   53
0964:  CALL   0082
0968:  BNC   09B2
096A:  MOVFF  2E,4B
096E:  MOVFF  2D,4A
0972:  MOVFF  2C,49
0976:  MOVFF  2B,48
097A:  MOVFF  32,4F
097E:  MOVFF  31,4E
0982:  MOVFF  30,4D
0986:  MOVFF  2F,4C
098A:  CALL   00F8
098E:  MOVFF  03,3A
0992:  MOVFF  02,39
0996:  MOVFF  01,38
099A:  MOVFF  00,37
099E:  MOVFF  03,3E
09A2:  MOVFF  02,3D
09A6:  MOVFF  01,3C
09AA:  MOVFF  00,3B
09AE:  BRA    08C6
09B0:  BRA    09F8
09B2:  MOVFF  2E,4B
09B6:  MOVFF  2D,4A
09BA:  MOVFF  2C,49
09BE:  MOVFF  2B,48
09C2:  MOVFF  32,4F
09C6:  MOVFF  31,4E
09CA:  MOVFF  30,4D
09CE:  MOVFF  2F,4C
09D2:  CALL   00F8
09D6:  MOVFF  03,3A
09DA:  MOVFF  02,39
09DE:  MOVFF  01,38
09E2:  MOVFF  00,37
09E6:  MOVFF  03,3E
09EA:  MOVFF  02,3D
09EE:  MOVFF  01,3C
09F2:  MOVFF  00,3B
09F6:  BRA    08E0
09F8:  MOVFF  03,36
09FC:  MOVFF  02,35
0A00:  MOVFF  01,34
0A04:  MOVFF  00,33
....................       return(x-(i*y));
0A08:  MOVFF  36,52
0A0C:  MOVFF  35,51
0A10:  MOVFF  34,50
0A14:  MOVFF  33,4F
0A18:  MOVFF  32,56
0A1C:  MOVFF  31,55
0A20:  MOVFF  30,54
0A24:  MOVFF  2F,53
0A28:  RCALL  0252
0A2A:  BSF    FD8.1
0A2C:  MOVFF  2E,56
0A30:  MOVFF  2D,55
0A34:  MOVFF  2C,54
0A38:  MOVFF  2B,53
0A3C:  MOVFF  03,5A
0A40:  MOVFF  02,59
0A44:  MOVFF  01,58
0A48:  MOVFF  00,57
0A4C:  RCALL  0344
0A4E:  BRA    0A50
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
0A50:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
0DEA:  MOVFF  32,52
0DEE:  MOVFF  31,51
0DF2:  MOVFF  30,50
0DF6:  MOVFF  2F,4F
0DFA:  MOVLW  3B
0DFC:  MOVWF  56
0DFE:  MOVLW  AA
0E00:  MOVWF  55
0E02:  MOVLW  38
0E04:  MOVWF  54
0E06:  MOVLW  7F
0E08:  MOVWF  53
0E0A:  CALL   0252
0E0E:  MOVFF  03,52
0E12:  MOVFF  02,51
0E16:  MOVFF  01,50
0E1A:  MOVFF  00,4F
0E1E:  CALL   0004
0E22:  MOVFF  01,3F
....................    s = 0;
0E26:  BCF    40.0
....................    y = x;
0E28:  MOVFF  32,36
0E2C:  MOVFF  31,35
0E30:  MOVFF  30,34
0E34:  MOVFF  2F,33
.................... 
....................    if (x < 0)
0E38:  MOVFF  32,52
0E3C:  MOVFF  31,51
0E40:  MOVFF  30,50
0E44:  MOVFF  2F,4F
0E48:  CLRF   56
0E4A:  CLRF   55
0E4C:  CLRF   54
0E4E:  CLRF   53
0E50:  CALL   0082
0E54:  BNC   0E60
....................    {
....................       s = 1;
0E56:  BSF    40.0
....................       n = -n;
0E58:  NEGF   3F
....................       y = -y;
0E5A:  MOVF   34,W
0E5C:  XORLW  80
0E5E:  MOVWF  34
....................    }
.................... 
....................    res = 0.0;
0E60:  CLRF   3A
0E62:  CLRF   39
0E64:  CLRF   38
0E66:  CLRF   37
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
0E68:  MOVLW  37
0E6A:  MOVWF  FE9
0E6C:  CLRF   FEA
0E6E:  MOVLW  7F
0E70:  ADDWF  3F,W
0E72:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
0E74:  MOVFF  36,52
0E78:  MOVFF  35,51
0E7C:  MOVFF  34,50
0E80:  MOVFF  33,4F
0E84:  MOVLW  3B
0E86:  MOVWF  56
0E88:  MOVLW  AA
0E8A:  MOVWF  55
0E8C:  MOVLW  38
0E8E:  MOVWF  54
0E90:  MOVLW  7F
0E92:  MOVWF  53
0E94:  CALL   0252
0E98:  MOVFF  03,44
0E9C:  MOVFF  02,43
0EA0:  MOVFF  01,42
0EA4:  MOVFF  00,41
0EA8:  CLRF   46
0EAA:  MOVFF  3F,45
0EAE:  BTFSC  45.7
0EB0:  DECF   46,F
0EB2:  RCALL  0A52
0EB4:  BSF    FD8.1
0EB6:  MOVFF  44,56
0EBA:  MOVFF  43,55
0EBE:  MOVFF  42,54
0EC2:  MOVFF  41,53
0EC6:  MOVFF  03,5A
0ECA:  MOVFF  02,59
0ECE:  MOVFF  01,58
0ED2:  MOVFF  00,57
0ED6:  CALL   0344
0EDA:  MOVFF  03,36
0EDE:  MOVFF  02,35
0EE2:  MOVFF  01,34
0EE6:  MOVFF  00,33
.................... 
....................    r = pe[0]*y + pe[1];
0EEA:  MOVLW  7C
0EEC:  MOVWF  52
0EEE:  MOVLW  88
0EF0:  MOVWF  51
0EF2:  MOVLW  59
0EF4:  MOVWF  50
0EF6:  MOVLW  72
0EF8:  MOVWF  4F
0EFA:  MOVFF  36,56
0EFE:  MOVFF  35,55
0F02:  MOVFF  34,54
0F06:  MOVFF  33,53
0F0A:  CALL   0252
0F0E:  MOVFF  03,44
0F12:  MOVFF  02,43
0F16:  MOVFF  01,42
0F1A:  MOVFF  00,41
0F1E:  BCF    FD8.1
0F20:  MOVFF  03,56
0F24:  MOVFF  02,55
0F28:  MOVFF  01,54
0F2C:  MOVFF  00,53
0F30:  MOVLW  E0
0F32:  MOVWF  5A
0F34:  MOVLW  97
0F36:  MOVWF  59
0F38:  MOVLW  26
0F3A:  MOVWF  58
0F3C:  MOVLW  75
0F3E:  MOVWF  57
0F40:  CALL   0344
0F44:  MOVFF  03,3E
0F48:  MOVFF  02,3D
0F4C:  MOVFF  01,3C
0F50:  MOVFF  00,3B
....................    r = r*y + pe[2];
0F54:  MOVFF  3E,52
0F58:  MOVFF  3D,51
0F5C:  MOVFF  3C,50
0F60:  MOVFF  3B,4F
0F64:  MOVFF  36,56
0F68:  MOVFF  35,55
0F6C:  MOVFF  34,54
0F70:  MOVFF  33,53
0F74:  CALL   0252
0F78:  MOVFF  03,44
0F7C:  MOVFF  02,43
0F80:  MOVFF  01,42
0F84:  MOVFF  00,41
0F88:  BCF    FD8.1
0F8A:  MOVFF  03,56
0F8E:  MOVFF  02,55
0F92:  MOVFF  01,54
0F96:  MOVFF  00,53
0F9A:  MOVLW  C4
0F9C:  MOVWF  5A
0F9E:  MOVLW  1D
0FA0:  MOVWF  59
0FA2:  MOVLW  1E
0FA4:  MOVWF  58
0FA6:  MOVLW  78
0FA8:  MOVWF  57
0FAA:  CALL   0344
0FAE:  MOVFF  03,3E
0FB2:  MOVFF  02,3D
0FB6:  MOVFF  01,3C
0FBA:  MOVFF  00,3B
....................    r = r*y + pe[3];
0FBE:  MOVFF  3E,52
0FC2:  MOVFF  3D,51
0FC6:  MOVFF  3C,50
0FCA:  MOVFF  3B,4F
0FCE:  MOVFF  36,56
0FD2:  MOVFF  35,55
0FD6:  MOVFF  34,54
0FDA:  MOVFF  33,53
0FDE:  CALL   0252
0FE2:  MOVFF  03,44
0FE6:  MOVFF  02,43
0FEA:  MOVFF  01,42
0FEE:  MOVFF  00,41
0FF2:  BCF    FD8.1
0FF4:  MOVFF  03,56
0FF8:  MOVFF  02,55
0FFC:  MOVFF  01,54
1000:  MOVFF  00,53
1004:  MOVLW  5E
1006:  MOVWF  5A
1008:  MOVLW  50
100A:  MOVWF  59
100C:  MOVLW  63
100E:  MOVWF  58
1010:  MOVLW  7A
1012:  MOVWF  57
1014:  CALL   0344
1018:  MOVFF  03,3E
101C:  MOVFF  02,3D
1020:  MOVFF  01,3C
1024:  MOVFF  00,3B
....................    r = r*y + pe[4];
1028:  MOVFF  3E,52
102C:  MOVFF  3D,51
1030:  MOVFF  3C,50
1034:  MOVFF  3B,4F
1038:  MOVFF  36,56
103C:  MOVFF  35,55
1040:  MOVFF  34,54
1044:  MOVFF  33,53
1048:  CALL   0252
104C:  MOVFF  03,44
1050:  MOVFF  02,43
1054:  MOVFF  01,42
1058:  MOVFF  00,41
105C:  BCF    FD8.1
105E:  MOVFF  03,56
1062:  MOVFF  02,55
1066:  MOVFF  01,54
106A:  MOVFF  00,53
106E:  MOVLW  1A
1070:  MOVWF  5A
1072:  MOVLW  FE
1074:  MOVWF  59
1076:  MOVLW  75
1078:  MOVWF  58
107A:  MOVLW  7C
107C:  MOVWF  57
107E:  CALL   0344
1082:  MOVFF  03,3E
1086:  MOVFF  02,3D
108A:  MOVFF  01,3C
108E:  MOVFF  00,3B
....................    r = r*y + pe[5];
1092:  MOVFF  3E,52
1096:  MOVFF  3D,51
109A:  MOVFF  3C,50
109E:  MOVFF  3B,4F
10A2:  MOVFF  36,56
10A6:  MOVFF  35,55
10AA:  MOVFF  34,54
10AE:  MOVFF  33,53
10B2:  CALL   0252
10B6:  MOVFF  03,44
10BA:  MOVFF  02,43
10BE:  MOVFF  01,42
10C2:  MOVFF  00,41
10C6:  BCF    FD8.1
10C8:  MOVFF  03,56
10CC:  MOVFF  02,55
10D0:  MOVFF  01,54
10D4:  MOVFF  00,53
10D8:  MOVLW  18
10DA:  MOVWF  5A
10DC:  MOVLW  72
10DE:  MOVWF  59
10E0:  MOVLW  31
10E2:  MOVWF  58
10E4:  MOVLW  7E
10E6:  MOVWF  57
10E8:  CALL   0344
10EC:  MOVFF  03,3E
10F0:  MOVFF  02,3D
10F4:  MOVFF  01,3C
10F8:  MOVFF  00,3B
.................... 
....................    res = res*(1.0 + y*r);
10FC:  MOVFF  36,52
1100:  MOVFF  35,51
1104:  MOVFF  34,50
1108:  MOVFF  33,4F
110C:  MOVFF  3E,56
1110:  MOVFF  3D,55
1114:  MOVFF  3C,54
1118:  MOVFF  3B,53
111C:  CALL   0252
1120:  BCF    FD8.1
1122:  CLRF   56
1124:  CLRF   55
1126:  CLRF   54
1128:  MOVLW  7F
112A:  MOVWF  53
112C:  MOVFF  03,5A
1130:  MOVFF  02,59
1134:  MOVFF  01,58
1138:  MOVFF  00,57
113C:  CALL   0344
1140:  MOVFF  3A,52
1144:  MOVFF  39,51
1148:  MOVFF  38,50
114C:  MOVFF  37,4F
1150:  MOVFF  03,56
1154:  MOVFF  02,55
1158:  MOVFF  01,54
115C:  MOVFF  00,53
1160:  CALL   0252
1164:  MOVFF  03,3A
1168:  MOVFF  02,39
116C:  MOVFF  01,38
1170:  MOVFF  00,37
.................... 
....................    if (s)
1174:  BTFSS  40.0
1176:  BRA    11A6
....................       res = 1.0/res;
1178:  CLRF   4B
117A:  CLRF   4A
117C:  CLRF   49
117E:  MOVLW  7F
1180:  MOVWF  48
1182:  MOVFF  3A,4F
1186:  MOVFF  39,4E
118A:  MOVFF  38,4D
118E:  MOVFF  37,4C
1192:  CALL   00F8
1196:  MOVFF  03,3A
119A:  MOVFF  02,39
119E:  MOVFF  01,38
11A2:  MOVFF  00,37
....................    return(res);
11A6:  MOVFF  37,00
11AA:  MOVFF  38,01
11AE:  MOVFF  39,02
11B2:  MOVFF  3A,03
11B6:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
0A9A:  MOVFF  32,36
0A9E:  MOVFF  31,35
0AA2:  MOVFF  30,34
0AA6:  MOVFF  2F,33
.................... 
....................    if (y != 1.0)
0AAA:  MOVFF  36,52
0AAE:  MOVFF  35,51
0AB2:  MOVFF  34,50
0AB6:  MOVFF  33,4F
0ABA:  CLRF   56
0ABC:  CLRF   55
0ABE:  CLRF   54
0AC0:  MOVLW  7F
0AC2:  MOVWF  53
0AC4:  CALL   0082
0AC8:  BTFSC  FD8.2
0ACA:  BRA    0DD0
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
0ACC:  MOVLW  33
0ACE:  MOVWF  FE9
0AD0:  CLRF   FEA
0AD2:  MOVLW  7E
0AD4:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
0AD6:  BSF    FD8.1
0AD8:  MOVFF  36,56
0ADC:  MOVFF  35,55
0AE0:  MOVFF  34,54
0AE4:  MOVFF  33,53
0AE8:  CLRF   5A
0AEA:  CLRF   59
0AEC:  CLRF   58
0AEE:  MOVLW  7F
0AF0:  MOVWF  57
0AF2:  RCALL  0344
0AF4:  MOVFF  03,47
0AF8:  MOVFF  02,46
0AFC:  MOVFF  01,45
0B00:  MOVFF  00,44
0B04:  BCF    FD8.1
0B06:  MOVFF  36,56
0B0A:  MOVFF  35,55
0B0E:  MOVFF  34,54
0B12:  MOVFF  33,53
0B16:  CLRF   5A
0B18:  CLRF   59
0B1A:  CLRF   58
0B1C:  MOVLW  7F
0B1E:  MOVWF  57
0B20:  RCALL  0344
0B22:  MOVFF  47,4B
0B26:  MOVFF  46,4A
0B2A:  MOVFF  45,49
0B2E:  MOVFF  44,48
0B32:  MOVFF  03,4F
0B36:  MOVFF  02,4E
0B3A:  MOVFF  01,4D
0B3E:  MOVFF  00,4C
0B42:  CALL   00F8
0B46:  MOVFF  03,36
0B4A:  MOVFF  02,35
0B4E:  MOVFF  01,34
0B52:  MOVFF  00,33
.................... 
....................       y2=y*y;
0B56:  MOVFF  36,52
0B5A:  MOVFF  35,51
0B5E:  MOVFF  34,50
0B62:  MOVFF  33,4F
0B66:  MOVFF  36,56
0B6A:  MOVFF  35,55
0B6E:  MOVFF  34,54
0B72:  MOVFF  33,53
0B76:  CALL   0252
0B7A:  MOVFF  03,42
0B7E:  MOVFF  02,41
0B82:  MOVFF  01,40
0B86:  MOVFF  00,3F
.................... 
....................       res = pl[0]*y2 + pl[1];
0B8A:  MOVLW  99
0B8C:  MOVWF  52
0B8E:  MOVLW  47
0B90:  MOVWF  51
0B92:  MOVLW  8A
0B94:  MOVWF  50
0B96:  MOVLW  7F
0B98:  MOVWF  4F
0B9A:  MOVFF  42,56
0B9E:  MOVFF  41,55
0BA2:  MOVFF  40,54
0BA6:  MOVFF  3F,53
0BAA:  CALL   0252
0BAE:  MOVFF  03,47
0BB2:  MOVFF  02,46
0BB6:  MOVFF  01,45
0BBA:  MOVFF  00,44
0BBE:  BCF    FD8.1
0BC0:  MOVFF  03,56
0BC4:  MOVFF  02,55
0BC8:  MOVFF  01,54
0BCC:  MOVFF  00,53
0BD0:  CLRF   5A
0BD2:  CLRF   59
0BD4:  CLRF   58
0BD6:  MOVLW  80
0BD8:  MOVWF  57
0BDA:  CALL   0344
0BDE:  MOVFF  03,3A
0BE2:  MOVFF  02,39
0BE6:  MOVFF  01,38
0BEA:  MOVFF  00,37
.................... 
....................       r = ql[0]*y2 + ql[1];
0BEE:  MOVLW  4C
0BF0:  MOVWF  52
0BF2:  MOVLW  F3
0BF4:  MOVWF  51
0BF6:  MOVLW  3A
0BF8:  MOVWF  50
0BFA:  MOVLW  7B
0BFC:  MOVWF  4F
0BFE:  MOVFF  42,56
0C02:  MOVFF  41,55
0C06:  MOVFF  40,54
0C0A:  MOVFF  3F,53
0C0E:  CALL   0252
0C12:  MOVFF  03,47
0C16:  MOVFF  02,46
0C1A:  MOVFF  01,45
0C1E:  MOVFF  00,44
0C22:  BCF    FD8.1
0C24:  MOVFF  03,56
0C28:  MOVFF  02,55
0C2C:  MOVFF  01,54
0C30:  MOVFF  00,53
0C34:  MOVLW  2B
0C36:  MOVWF  5A
0C38:  MOVLW  9D
0C3A:  MOVWF  59
0C3C:  MOVLW  DF
0C3E:  MOVWF  58
0C40:  MOVLW  7E
0C42:  MOVWF  57
0C44:  CALL   0344
0C48:  MOVFF  03,3E
0C4C:  MOVFF  02,3D
0C50:  MOVFF  01,3C
0C54:  MOVFF  00,3B
....................       r = r*y2 + 1.0;
0C58:  MOVFF  3E,52
0C5C:  MOVFF  3D,51
0C60:  MOVFF  3C,50
0C64:  MOVFF  3B,4F
0C68:  MOVFF  42,56
0C6C:  MOVFF  41,55
0C70:  MOVFF  40,54
0C74:  MOVFF  3F,53
0C78:  CALL   0252
0C7C:  MOVFF  03,47
0C80:  MOVFF  02,46
0C84:  MOVFF  01,45
0C88:  MOVFF  00,44
0C8C:  BCF    FD8.1
0C8E:  MOVFF  03,56
0C92:  MOVFF  02,55
0C96:  MOVFF  01,54
0C9A:  MOVFF  00,53
0C9E:  CLRF   5A
0CA0:  CLRF   59
0CA2:  CLRF   58
0CA4:  MOVLW  7F
0CA6:  MOVWF  57
0CA8:  CALL   0344
0CAC:  MOVFF  03,3E
0CB0:  MOVFF  02,3D
0CB4:  MOVFF  01,3C
0CB8:  MOVFF  00,3B
.................... 
....................       res = y*res/r;
0CBC:  MOVFF  36,52
0CC0:  MOVFF  35,51
0CC4:  MOVFF  34,50
0CC8:  MOVFF  33,4F
0CCC:  MOVFF  3A,56
0CD0:  MOVFF  39,55
0CD4:  MOVFF  38,54
0CD8:  MOVFF  37,53
0CDC:  CALL   0252
0CE0:  MOVFF  03,47
0CE4:  MOVFF  02,46
0CE8:  MOVFF  01,45
0CEC:  MOVFF  00,44
0CF0:  MOVFF  03,4B
0CF4:  MOVFF  02,4A
0CF8:  MOVFF  01,49
0CFC:  MOVFF  00,48
0D00:  MOVFF  3E,4F
0D04:  MOVFF  3D,4E
0D08:  MOVFF  3C,4D
0D0C:  MOVFF  3B,4C
0D10:  CALL   00F8
0D14:  MOVFF  03,3A
0D18:  MOVFF  02,39
0D1C:  MOVFF  01,38
0D20:  MOVFF  00,37
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
0D24:  MOVLW  2F
0D26:  MOVWF  FE9
0D28:  CLRF   FEA
0D2A:  MOVLW  7E
0D2C:  SUBWF  FEF,W
0D2E:  MOVWF  43
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
0D30:  BTFSS  43.7
0D32:  BRA    0D58
....................          r = -(float32)-n;
0D34:  MOVLW  00
0D36:  BSF    FD8.0
0D38:  SUBFWB 43,W
0D3A:  CLRF   46
0D3C:  MOVWF  45
0D3E:  BTFSC  45.7
0D40:  DECF   46,F
0D42:  RCALL  0A52
0D44:  MOVFF  00,3B
0D48:  MOVF   01,W
0D4A:  XORLW  80
0D4C:  MOVWF  3C
0D4E:  MOVFF  02,3D
0D52:  MOVFF  03,3E
0D56:  BRA    0D74
....................       else
....................          r = (float32)n;
0D58:  CLRF   46
0D5A:  MOVFF  43,45
0D5E:  BTFSC  45.7
0D60:  DECF   46,F
0D62:  RCALL  0A52
0D64:  MOVFF  03,3E
0D68:  MOVFF  02,3D
0D6C:  MOVFF  01,3C
0D70:  MOVFF  00,3B
.................... 
....................       res += r*LN2;
0D74:  MOVFF  3E,52
0D78:  MOVFF  3D,51
0D7C:  MOVFF  3C,50
0D80:  MOVFF  3B,4F
0D84:  MOVLW  18
0D86:  MOVWF  56
0D88:  MOVLW  72
0D8A:  MOVWF  55
0D8C:  MOVLW  31
0D8E:  MOVWF  54
0D90:  MOVLW  7E
0D92:  MOVWF  53
0D94:  CALL   0252
0D98:  BCF    FD8.1
0D9A:  MOVFF  3A,56
0D9E:  MOVFF  39,55
0DA2:  MOVFF  38,54
0DA6:  MOVFF  37,53
0DAA:  MOVFF  03,5A
0DAE:  MOVFF  02,59
0DB2:  MOVFF  01,58
0DB6:  MOVFF  00,57
0DBA:  CALL   0344
0DBE:  MOVFF  03,3A
0DC2:  MOVFF  02,39
0DC6:  MOVFF  01,38
0DCA:  MOVFF  00,37
....................    }
0DCE:  BRA    0DD8
.................... 
....................    else
....................       res = 0.0;
0DD0:  CLRF   3A
0DD2:  CLRF   39
0DD4:  CLRF   38
0DD6:  CLRF   37
.................... 
....................    return(res);
0DD8:  MOVFF  37,00
0DDC:  MOVFF  38,01
0DE0:  MOVFF  39,02
0DE4:  MOVFF  3A,03
0DE8:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
11B8:  MOVFF  26,52
11BC:  MOVFF  25,51
11C0:  MOVFF  24,50
11C4:  MOVFF  23,4F
11C8:  CLRF   56
11CA:  CLRF   55
11CC:  CLRF   54
11CE:  CLRF   53
11D0:  CALL   0082
11D4:  BTFSS  FD8.0
11D6:  BRA    1358
11D8:  MOVFF  2A,2E
11DC:  MOVFF  29,2D
11E0:  MOVFF  28,2C
11E4:  MOVFF  27,2B
11E8:  CLRF   32
11EA:  CLRF   31
11EC:  CLRF   30
11EE:  MOVLW  7F
11F0:  MOVWF  2F
11F2:  CALL   08F8
11F6:  MOVFF  03,2E
11FA:  MOVFF  02,2D
11FE:  MOVFF  01,2C
1202:  MOVFF  00,2B
1206:  MOVFF  03,52
120A:  MOVFF  02,51
120E:  MOVFF  01,50
1212:  MOVFF  00,4F
1216:  CLRF   56
1218:  CLRF   55
121A:  CLRF   54
121C:  CLRF   53
121E:  CALL   0082
1222:  BTFSS  FD8.2
1224:  BRA    1358
....................       if(fmod(y, 2) == 0) {
1226:  MOVFF  2A,2E
122A:  MOVFF  29,2D
122E:  MOVFF  28,2C
1232:  MOVFF  27,2B
1236:  CLRF   32
1238:  CLRF   31
123A:  CLRF   30
123C:  MOVLW  80
123E:  MOVWF  2F
1240:  CALL   08F8
1244:  MOVFF  03,2E
1248:  MOVFF  02,2D
124C:  MOVFF  01,2C
1250:  MOVFF  00,2B
1254:  MOVFF  03,52
1258:  MOVFF  02,51
125C:  MOVFF  01,50
1260:  MOVFF  00,4F
1264:  CLRF   56
1266:  CLRF   55
1268:  CLRF   54
126A:  CLRF   53
126C:  CALL   0082
1270:  BNZ   12E2
....................          return (exp(log(-x) * y));
1272:  MOVF   24,W
1274:  XORLW  80
1276:  MOVWF  2C
1278:  MOVFF  26,32
127C:  MOVFF  25,31
1280:  MOVWF  30
1282:  MOVFF  23,2F
1286:  RCALL  0A9A
1288:  MOVFF  03,2E
128C:  MOVFF  02,2D
1290:  MOVFF  01,2C
1294:  MOVFF  00,2B
1298:  MOVFF  03,52
129C:  MOVFF  02,51
12A0:  MOVFF  01,50
12A4:  MOVFF  00,4F
12A8:  MOVFF  2A,56
12AC:  MOVFF  29,55
12B0:  MOVFF  28,54
12B4:  MOVFF  27,53
12B8:  CALL   0252
12BC:  MOVFF  03,2E
12C0:  MOVFF  02,2D
12C4:  MOVFF  01,2C
12C8:  MOVFF  00,2B
12CC:  MOVFF  03,32
12D0:  MOVFF  02,31
12D4:  MOVFF  01,30
12D8:  MOVFF  00,2F
12DC:  RCALL  0DEA
12DE:  BRA    1482
....................       } else {
12E0:  BRA    1356
....................          return (-exp(log(-x) * y));
12E2:  MOVF   24,W
12E4:  XORLW  80
12E6:  MOVWF  2C
12E8:  MOVFF  26,32
12EC:  MOVFF  25,31
12F0:  MOVWF  30
12F2:  MOVFF  23,2F
12F6:  CALL   0A9A
12FA:  MOVFF  03,2E
12FE:  MOVFF  02,2D
1302:  MOVFF  01,2C
1306:  MOVFF  00,2B
130A:  MOVFF  03,52
130E:  MOVFF  02,51
1312:  MOVFF  01,50
1316:  MOVFF  00,4F
131A:  MOVFF  2A,56
131E:  MOVFF  29,55
1322:  MOVFF  28,54
1326:  MOVFF  27,53
132A:  CALL   0252
132E:  MOVFF  03,2E
1332:  MOVFF  02,2D
1336:  MOVFF  01,2C
133A:  MOVFF  00,2B
133E:  MOVFF  03,32
1342:  MOVFF  02,31
1346:  MOVFF  01,30
134A:  MOVFF  00,2F
134E:  RCALL  0DEA
1350:  MOVLW  80
1352:  XORWF  01,F
1354:  BRA    1482
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
1356:  BRA    1482
1358:  MOVFF  26,52
135C:  MOVFF  25,51
1360:  MOVFF  24,50
1364:  MOVFF  23,4F
1368:  CLRF   56
136A:  CLRF   55
136C:  CLRF   54
136E:  CLRF   53
1370:  CALL   0082
1374:  BNC   13CE
1376:  MOVFF  2A,2E
137A:  MOVFF  29,2D
137E:  MOVFF  28,2C
1382:  MOVFF  27,2B
1386:  CLRF   32
1388:  CLRF   31
138A:  CLRF   30
138C:  MOVLW  7F
138E:  MOVWF  2F
1390:  CALL   08F8
1394:  MOVFF  03,2E
1398:  MOVFF  02,2D
139C:  MOVFF  01,2C
13A0:  MOVFF  00,2B
13A4:  MOVFF  03,52
13A8:  MOVFF  02,51
13AC:  MOVFF  01,50
13B0:  MOVFF  00,4F
13B4:  CLRF   56
13B6:  CLRF   55
13B8:  CLRF   54
13BA:  CLRF   53
13BC:  CALL   0082
13C0:  BZ    13CE
....................       return 0;
13C2:  CLRF   00
13C4:  CLRF   01
13C6:  CLRF   02
13C8:  CLRF   03
13CA:  BRA    1482
....................    } else {
13CC:  BRA    1482
....................       if(x != 0 || 0 >= y) {
13CE:  MOVFF  26,52
13D2:  MOVFF  25,51
13D6:  MOVFF  24,50
13DA:  MOVFF  23,4F
13DE:  CLRF   56
13E0:  CLRF   55
13E2:  CLRF   54
13E4:  CLRF   53
13E6:  CALL   0082
13EA:  BNZ   140C
13EC:  MOVFF  2A,52
13F0:  MOVFF  29,51
13F4:  MOVFF  28,50
13F8:  MOVFF  27,4F
13FC:  CLRF   56
13FE:  CLRF   55
1400:  CLRF   54
1402:  CLRF   53
1404:  CALL   0082
1408:  BC    140C
140A:  BNZ   147A
....................          return (exp(log(x) * y));
140C:  MOVFF  26,32
1410:  MOVFF  25,31
1414:  MOVFF  24,30
1418:  MOVFF  23,2F
141C:  CALL   0A9A
1420:  MOVFF  03,2E
1424:  MOVFF  02,2D
1428:  MOVFF  01,2C
142C:  MOVFF  00,2B
1430:  MOVFF  03,52
1434:  MOVFF  02,51
1438:  MOVFF  01,50
143C:  MOVFF  00,4F
1440:  MOVFF  2A,56
1444:  MOVFF  29,55
1448:  MOVFF  28,54
144C:  MOVFF  27,53
1450:  CALL   0252
1454:  MOVFF  03,2E
1458:  MOVFF  02,2D
145C:  MOVFF  01,2C
1460:  MOVFF  00,2B
1464:  MOVFF  03,32
1468:  MOVFF  02,31
146C:  MOVFF  01,30
1470:  MOVFF  00,2F
1474:  RCALL  0DEA
1476:  BRA    1482
....................       } else return 0;
1478:  BRA    1482
147A:  CLRF   00
147C:  CLRF   01
147E:  CLRF   02
1480:  CLRF   03
....................    }
1482:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... void Acoplamiento();
.................... void Display(float);
.................... void Descomponer(int *, int *, int *, int *, float);
.................... 
.................... #define LED pin_d0
.................... // Displays
.................... #define D1 pin_e0
.................... #define D2 pin_d4
.................... #define D3 pin_d6
.................... #define D4 pin_d7
.................... // Botones
.................... #define BOT1 pin_d2
.................... #define BOT2 pin_d3
.................... #define BOT3 pin_c6
.................... #define BOT4 pin_c7
.................... // Distancia Constante
.................... #define MIN 10
.................... #define MAX 31
.................... 
.................... int vec_c[10] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D,0x7D,0x07,0x7F,0x67}; // Numeros para display Catodo
.................... int16 duty[] = {200, 500, 850}; // Obtenidos con el excel
.................... int MODO = 1; // Bandera para establecer el MODO
.................... 
.................... float dist_act; 
.................... int16 dist_prox, cont = 0;
.................... 
.................... void main()
*
1D7C:  CLRF   FF8
1D7E:  BCF    FD0.7
1D80:  MOVLW  01
1D82:  MOVWF  14
1D84:  CLRF   1C
1D86:  CLRF   1B
1D88:  MOVF   FC1,W
1D8A:  ANDLW  C0
1D8C:  IORLW  0F
1D8E:  MOVWF  FC1
1D90:  MOVLW  07
1D92:  MOVWF  FB4
1D94:  MOVLW  3F
1D96:  MOVWF  04
1D98:  MOVLW  06
1D9A:  MOVWF  05
1D9C:  MOVLW  5B
1D9E:  MOVWF  06
1DA0:  MOVLW  4F
1DA2:  MOVWF  07
1DA4:  MOVLW  66
1DA6:  MOVWF  08
1DA8:  MOVLW  6D
1DAA:  MOVWF  09
1DAC:  MOVLW  7D
1DAE:  MOVWF  0A
1DB0:  MOVLW  07
1DB2:  MOVWF  0B
1DB4:  MOVLW  7F
1DB6:  MOVWF  0C
1DB8:  MOVLW  67
1DBA:  MOVWF  0D
1DBC:  MOVLW  C8
1DBE:  MOVWF  0E
1DC0:  CLRF   0F
1DC2:  MOVLW  F4
1DC4:  MOVWF  10
1DC6:  MOVLW  01
1DC8:  MOVWF  11
1DCA:  MOVLW  52
1DCC:  MOVWF  12
1DCE:  MOVLW  03
1DD0:  MOVWF  13
.................... {  
....................    // CONFIFGURACION DE ADC
....................    setup_adc(adc_clock_div_2); // Sincronizamos las frecuencias
1DD2:  MOVF   FC0,W
1DD4:  ANDLW  C0
1DD6:  MOVWF  FC0
1DD8:  BSF    FC0.7
1DDA:  BSF    FC2.0
....................    
....................    set_tris_a(0b00001111); // 1 entrada 0 salida
1DDC:  MOVLW  0F
1DDE:  MOVWF  F92
....................    
....................    // CONFIGURACION DE PWM
....................    setup_timer_2(T2_DIV_BY_4, 249, 1); // Primer parametro modificamos el preescalador
1DE0:  MOVLW  00
1DE2:  IORLW  05
1DE4:  MOVWF  FCA
1DE6:  MOVLW  F9
1DE8:  MOVWF  FCB
....................    setup_ccp1(CCP_PWM | CCP_PWM_HALF_BRIDGE, 10); // Activa el PMW en P1A y P1B. (Activar PWM, Modo de puente H, Desfase (En funcion de la cuenta del timer ))
1DEA:  BCF    F94.2
1DEC:  BCF    F8B.2
1DEE:  BCF    F95.5
1DF0:  MOVLW  8C
1DF2:  MOVWF  FBD
1DF4:  MOVLW  0A
1DF6:  MOVWF  FB7
1DF8:  CLRF   FB6
....................    
....................    set_pwm1_duty(duty[1]);
1DFA:  MOVFF  11,02
1DFE:  MOVFF  10,01
1E02:  RRCF   02,F
1E04:  RRCF   01,F
1E06:  RRCF   02,F
1E08:  RRCF   01,F
1E0A:  RRCF   02,F
1E0C:  MOVFF  01,FBE
1E10:  RRCF   02,F
1E12:  RRCF   02,W
1E14:  ANDLW  30
1E16:  MOVWF  00
1E18:  MOVF   FBD,W
1E1A:  ANDLW  CF
1E1C:  IORWF  00,W
1E1E:  MOVWF  FBD
....................    
....................    while(true)
....................    {   
....................       cont++;
1E20:  INCF   1B,F
1E22:  BTFSC  FD8.2
1E24:  INCF   1C,F
....................       
....................       if(input(BOT1)) // Si se presiona el boton 1 (PREDETERMINADO)
1E26:  BSF    F95.2
1E28:  BTFSS  F83.2
1E2A:  BRA    1E30
....................          MODO = 1;
1E2C:  MOVLW  01
1E2E:  MOVWF  14
....................       if(input(BOT2))
1E30:  BSF    F95.3
1E32:  BTFSS  F83.3
1E34:  BRA    1E3A
....................          MODO = 2;
1E36:  MOVLW  02
1E38:  MOVWF  14
....................       
....................       if((((int16) dist_act) != dist_prox) || (cont == 30))
1E3A:  MOVFF  18,52
1E3E:  MOVFF  17,51
1E42:  MOVFF  16,50
1E46:  MOVFF  15,4F
1E4A:  CALL   0004
1E4E:  MOVFF  02,1E
1E52:  MOVFF  01,1D
1E56:  MOVF   19,W
1E58:  SUBWF  01,W
1E5A:  BNZ   1E70
1E5C:  MOVF   1A,W
1E5E:  SUBWF  1E,W
1E60:  BNZ   1E70
1E62:  MOVF   1B,W
1E64:  SUBLW  1E
1E66:  BTFSS  FD8.2
1E68:  BRA    20D2
1E6A:  MOVF   1C,F
1E6C:  BTFSS  FD8.2
1E6E:  BRA    20D2
....................       {
....................          cont = 0;
1E70:  CLRF   1C
1E72:  CLRF   1B
....................          
....................          // DISTANCIA ACTUAL
....................          setup_adc_ports(AN0_TO_AN1, VREF_VREF);
1E74:  MOVF   FC1,W
1E76:  ANDLW  C0
1E78:  IORLW  3D
1E7A:  MOVWF  FC1
....................          set_adc_channel(1);
1E7C:  MOVLW  04
1E7E:  MOVWF  01
1E80:  MOVF   FC2,W
1E82:  ANDLW  C3
1E84:  IORWF  01,W
1E86:  MOVWF  FC2
....................          delay_us(10);
1E88:  MOVLW  03
1E8A:  MOVWF  00
1E8C:  DECFSZ 00,F
1E8E:  BRA    1E8C
....................          dist_act = read_adc();
1E90:  BSF    FC2.1
1E92:  BTFSC  FC2.1
1E94:  BRA    1E92
1E96:  MOVFF  FC4,02
1E9A:  MOVFF  FC3,01
1E9E:  MOVFF  FC4,03
1EA2:  MOVFF  FC3,53
1EA6:  MOVFF  FC4,54
1EAA:  CALL   004C
1EAE:  MOVFF  03,18
1EB2:  MOVFF  02,17
1EB6:  MOVFF  01,16
1EBA:  MOVFF  00,15
....................          dist_act = 0.00000000005240528370241871*pow(dist_act, 4) - 0.0000001450873719796616*pow(dist_act, 3) + 0.0001552201168808377*pow(dist_act, 2) - 0.088303023838816*dist_act + 35.902364490061590; // A partir del sensor obtenemos la distancia actual
1EBE:  MOVFF  18,26
1EC2:  MOVFF  17,25
1EC6:  MOVFF  16,24
1ECA:  MOVFF  15,23
1ECE:  CLRF   2A
1ED0:  CLRF   29
1ED2:  CLRF   28
1ED4:  MOVLW  81
1ED6:  MOVWF  27
1ED8:  CALL   11B8
1EDC:  MOVLW  1B
1EDE:  MOVWF  52
1EE0:  MOVLW  7B
1EE2:  MOVWF  51
1EE4:  MOVLW  66
1EE6:  MOVWF  50
1EE8:  MOVLW  5C
1EEA:  MOVWF  4F
1EEC:  MOVFF  03,56
1EF0:  MOVFF  02,55
1EF4:  MOVFF  01,54
1EF8:  MOVFF  00,53
1EFC:  CALL   0252
1F00:  MOVFF  03,20
1F04:  MOVFF  02,1F
1F08:  MOVFF  01,1E
1F0C:  MOVFF  00,1D
1F10:  MOVFF  18,26
1F14:  MOVFF  17,25
1F18:  MOVFF  16,24
1F1C:  MOVFF  15,23
1F20:  CLRF   2A
1F22:  CLRF   29
1F24:  MOVLW  40
1F26:  MOVWF  28
1F28:  MOVLW  80
1F2A:  MOVWF  27
1F2C:  CALL   11B8
1F30:  MOVLW  50
1F32:  MOVWF  52
1F34:  MOVLW  C9
1F36:  MOVWF  51
1F38:  MOVLW  1B
1F3A:  MOVWF  50
1F3C:  MOVLW  68
1F3E:  MOVWF  4F
1F40:  MOVFF  03,56
1F44:  MOVFF  02,55
1F48:  MOVFF  01,54
1F4C:  MOVFF  00,53
1F50:  CALL   0252
1F54:  MOVFF  FEA,22
1F58:  MOVFF  FE9,21
1F5C:  BSF    FD8.1
1F5E:  MOVFF  20,56
1F62:  MOVFF  1F,55
1F66:  MOVFF  1E,54
1F6A:  MOVFF  1D,53
1F6E:  MOVFF  03,5A
1F72:  MOVFF  02,59
1F76:  MOVFF  01,58
1F7A:  MOVFF  00,57
1F7E:  CALL   0344
1F82:  MOVFF  22,FEA
1F86:  MOVFF  21,FE9
1F8A:  MOVFF  03,20
1F8E:  MOVFF  02,1F
1F92:  MOVFF  01,1E
1F96:  MOVFF  00,1D
1F9A:  MOVFF  18,26
1F9E:  MOVFF  17,25
1FA2:  MOVFF  16,24
1FA6:  MOVFF  15,23
1FAA:  CLRF   2A
1FAC:  CLRF   29
1FAE:  CLRF   28
1FB0:  MOVLW  80
1FB2:  MOVWF  27
1FB4:  CALL   11B8
1FB8:  MOVLW  95
1FBA:  MOVWF  52
1FBC:  MOVLW  C2
1FBE:  MOVWF  51
1FC0:  MOVLW  22
1FC2:  MOVWF  50
1FC4:  MOVLW  72
1FC6:  MOVWF  4F
1FC8:  MOVFF  03,56
1FCC:  MOVFF  02,55
1FD0:  MOVFF  01,54
1FD4:  MOVFF  00,53
1FD8:  CALL   0252
1FDC:  MOVFF  FEA,24
1FE0:  MOVFF  FE9,23
1FE4:  BCF    FD8.1
1FE6:  MOVFF  20,56
1FEA:  MOVFF  1F,55
1FEE:  MOVFF  1E,54
1FF2:  MOVFF  1D,53
1FF6:  MOVFF  03,5A
1FFA:  MOVFF  02,59
1FFE:  MOVFF  01,58
2002:  MOVFF  00,57
2006:  CALL   0344
200A:  MOVFF  24,FEA
200E:  MOVFF  23,FE9
2012:  MOVFF  03,20
2016:  MOVFF  02,1F
201A:  MOVFF  01,1E
201E:  MOVFF  00,1D
2022:  MOVLW  37
2024:  MOVWF  52
2026:  MOVLW  D8
2028:  MOVWF  51
202A:  MOVLW  34
202C:  MOVWF  50
202E:  MOVLW  7B
2030:  MOVWF  4F
2032:  MOVFF  18,56
2036:  MOVFF  17,55
203A:  MOVFF  16,54
203E:  MOVFF  15,53
2042:  CALL   0252
2046:  MOVFF  FEA,26
204A:  MOVFF  FE9,25
204E:  BSF    FD8.1
2050:  MOVFF  20,56
2054:  MOVFF  1F,55
2058:  MOVFF  1E,54
205C:  MOVFF  1D,53
2060:  MOVFF  03,5A
2064:  MOVFF  02,59
2068:  MOVFF  01,58
206C:  MOVFF  00,57
2070:  CALL   0344
2074:  MOVFF  26,FEA
2078:  MOVFF  25,FE9
207C:  MOVFF  03,20
2080:  MOVFF  02,1F
2084:  MOVFF  01,1E
2088:  MOVFF  00,1D
208C:  MOVFF  FEA,28
2090:  MOVFF  FE9,27
2094:  BCF    FD8.1
2096:  MOVFF  03,56
209A:  MOVFF  02,55
209E:  MOVFF  01,54
20A2:  MOVFF  00,53
20A6:  MOVLW  05
20A8:  MOVWF  5A
20AA:  MOVLW  9C
20AC:  MOVWF  59
20AE:  MOVLW  0F
20B0:  MOVWF  58
20B2:  MOVLW  84
20B4:  MOVWF  57
20B6:  CALL   0344
20BA:  MOVFF  28,FEA
20BE:  MOVFF  27,FE9
20C2:  MOVFF  03,18
20C6:  MOVFF  02,17
20CA:  MOVFF  01,16
20CE:  MOVFF  00,15
....................       }
....................       
....................       Display(dist_act);
20D2:  MOVFF  18,20
20D6:  MOVFF  17,1F
20DA:  MOVFF  16,1E
20DE:  MOVFF  15,1D
20E2:  BRA    1B06
....................       
....................       if(MODO == 1) // MODO 1 POTENCIOMETRO (PREDETERMINADO)
20E4:  DECFSZ 14,W
20E6:  BRA    21C0
....................       {
....................          // DISTANCIA PROXIMA
....................          setup_adc_ports(AN0_TO_AN1);
20E8:  MOVF   FC1,W
20EA:  ANDLW  C0
20EC:  IORLW  0D
20EE:  MOVWF  FC1
....................          set_adc_channel(0); // Lectura del Potenciometro (1023 -> 0)
20F0:  MOVLW  00
20F2:  MOVWF  01
20F4:  MOVF   FC2,W
20F6:  ANDLW  C3
20F8:  IORWF  01,W
20FA:  MOVWF  FC2
....................          delay_us(10);
20FC:  MOVLW  03
20FE:  MOVWF  00
2100:  DECFSZ 00,F
2102:  BRA    2100
....................          dist_prox = read_adc() / 1023.0 * (MAX - MIN) + MIN;
2104:  BSF    FC2.1
2106:  BTFSC  FC2.1
2108:  BRA    2106
210A:  MOVFF  FC4,02
210E:  MOVFF  FC3,01
2112:  MOVFF  FC4,54
2116:  MOVFF  FC3,53
211A:  CALL   004C
211E:  MOVFF  03,4B
2122:  MOVFF  02,4A
2126:  MOVFF  01,49
212A:  MOVFF  00,48
212E:  CLRF   4F
2130:  MOVLW  C0
2132:  MOVWF  4E
2134:  MOVLW  7F
2136:  MOVWF  4D
2138:  MOVLW  88
213A:  MOVWF  4C
213C:  CALL   00F8
2140:  MOVFF  03,20
2144:  MOVFF  02,1F
2148:  MOVFF  01,1E
214C:  MOVFF  00,1D
2150:  MOVFF  03,52
2154:  MOVFF  02,51
2158:  MOVFF  01,50
215C:  MOVFF  00,4F
2160:  CLRF   56
2162:  CLRF   55
2164:  MOVLW  28
2166:  MOVWF  54
2168:  MOVLW  83
216A:  MOVWF  53
216C:  CALL   0252
2170:  MOVFF  03,20
2174:  MOVFF  02,1F
2178:  MOVFF  01,1E
217C:  MOVFF  00,1D
2180:  BCF    FD8.1
2182:  MOVFF  03,56
2186:  MOVFF  02,55
218A:  MOVFF  01,54
218E:  MOVFF  00,53
2192:  CLRF   5A
2194:  CLRF   59
2196:  MOVLW  20
2198:  MOVWF  58
219A:  MOVLW  82
219C:  MOVWF  57
219E:  CALL   0344
21A2:  MOVFF  03,52
21A6:  MOVFF  02,51
21AA:  MOVFF  01,50
21AE:  MOVFF  00,4F
21B2:  CALL   0004
21B6:  MOVFF  02,1A
21BA:  MOVFF  01,19
....................       }
21BE:  BRA    21DE
....................       else if(MODO == 2) // MODO 2 BOTONES 3 Y 4
21C0:  MOVF   14,W
21C2:  SUBLW  02
21C4:  BNZ   21DE
....................       {  
....................          if(input(BOT3))
21C6:  BSF    F94.6
21C8:  BTFSS  F82.6
21CA:  BRA    21D2
....................          {
....................             // DISTANCIA PROXIMA
....................             dist_prox = 15;
21CC:  CLRF   1A
21CE:  MOVLW  0F
21D0:  MOVWF  19
....................          }
....................          if(input(BOT4))
21D2:  BSF    F94.7
21D4:  BTFSS  F82.7
21D6:  BRA    21DE
....................          {
....................             // DISTANCIA PROXIMA
....................             dist_prox = 25;
21D8:  CLRF   1A
21DA:  MOVLW  19
21DC:  MOVWF  19
....................          }
....................       }
....................       else {}
....................       
....................       // Cada ciclo despues de establecer la distancia proxima, hacemos acoplamiento
....................       
....................       if(((int16) dist_act) != dist_prox)
21DE:  MOVFF  18,52
21E2:  MOVFF  17,51
21E6:  MOVFF  16,50
21EA:  MOVFF  15,4F
21EE:  CALL   0004
21F2:  MOVFF  02,1E
21F6:  MOVFF  01,1D
21FA:  MOVF   19,W
21FC:  SUBWF  01,W
21FE:  BNZ   2206
2200:  MOVF   1A,W
2202:  SUBWF  1E,W
2204:  BZ    220E
....................       {
....................          output_high(LED); // LED de acoplamiento
2206:  BCF    F95.0
2208:  BSF    F8C.0
....................          Acoplamiento();
220A:  BRA    1CD4
....................       }  
220C:  BRA    2238
....................       else
....................       {
....................          output_low(LED); // LED de acoplamiento
220E:  BCF    F95.0
2210:  BCF    F8C.0
....................          set_pwm1_duty(duty[1]); // Detenemos el giro
2212:  MOVFF  11,02
2216:  MOVFF  10,01
221A:  RRCF   02,F
221C:  RRCF   01,F
221E:  RRCF   02,F
2220:  RRCF   01,F
2222:  RRCF   02,F
2224:  MOVFF  01,FBE
2228:  RRCF   02,F
222A:  RRCF   02,W
222C:  ANDLW  30
222E:  MOVWF  00
2230:  MOVF   FBD,W
2232:  ANDLW  CF
2234:  IORWF  00,W
2236:  MOVWF  FBD
....................       }
2238:  BRA    1E20
....................       
....................       //Display(dist_prox);
....................    }
.................... }
.................... 
223A:  SLEEP 
.................... void Acoplamiento()
.................... {
....................    int direccion;
....................    
....................    // Establecemos la direccion de giro
....................    
....................    if(dist_act < dist_prox)
*
1CD4:  MOVFF  1A,54
1CD8:  MOVFF  19,53
1CDC:  CALL   004C
1CE0:  MOVFF  18,52
1CE4:  MOVFF  17,51
1CE8:  MOVFF  16,50
1CEC:  MOVFF  15,4F
1CF0:  MOVFF  03,56
1CF4:  MOVFF  02,55
1CF8:  MOVFF  01,54
1CFC:  MOVFF  00,53
1D00:  CALL   0082
1D04:  BNC   1D0C
....................       direccion = 2; // Izquierda
1D06:  MOVLW  02
1D08:  MOVWF  1D
1D0A:  BRA    1D40
....................    else if(dist_act > dist_prox)
1D0C:  MOVFF  1A,54
1D10:  MOVFF  19,53
1D14:  CALL   004C
1D18:  MOVFF  03,52
1D1C:  MOVFF  02,51
1D20:  MOVFF  01,50
1D24:  MOVFF  00,4F
1D28:  MOVFF  18,56
1D2C:  MOVFF  17,55
1D30:  MOVFF  16,54
1D34:  MOVFF  15,53
1D38:  CALL   0082
1D3C:  BNC   1D40
....................       direccion = 0; // Derecha
1D3E:  CLRF   1D
....................    
....................    // Configuramos el giro
....................    set_pwm1_duty(duty[direccion]);
1D40:  BCF    FD8.0
1D42:  RLCF   1D,W
1D44:  CLRF   03
1D46:  ADDLW  0E
1D48:  MOVWF  FE9
1D4A:  MOVLW  00
1D4C:  ADDWFC 03,W
1D4E:  MOVWF  FEA
1D50:  MOVFF  FEC,1F
1D54:  MOVF   FED,F
1D56:  MOVFF  FEF,1E
1D5A:  RRCF   1F,F
1D5C:  RRCF   1E,F
1D5E:  RRCF   1F,F
1D60:  RRCF   1E,F
1D62:  RRCF   1F,F
1D64:  MOVFF  1E,FBE
1D68:  RRCF   1F,F
1D6A:  RRCF   1F,W
1D6C:  ANDLW  30
1D6E:  MOVWF  00
1D70:  MOVF   FBD,W
1D72:  ANDLW  CF
1D74:  IORWF  00,W
1D76:  MOVWF  FBD
1D78:  GOTO   220C (RETURN)
.................... }
.................... 
.................... void Display(float numero) // Tarda 20 ms
.................... { 
....................    int punto, n1, n2, n3, n4;
....................       
....................    // Se descompone en 4 numeros
....................    Descomponer( &n1, &n2, &n3, &n4, numero);
*
1B06:  CLRF   27
1B08:  MOVLW  22
1B0A:  MOVWF  26
1B0C:  CLRF   29
1B0E:  MOVLW  23
1B10:  MOVWF  28
1B12:  CLRF   2B
1B14:  MOVLW  24
1B16:  MOVWF  2A
1B18:  CLRF   2D
1B1A:  MOVLW  25
1B1C:  MOVWF  2C
1B1E:  MOVFF  20,31
1B22:  MOVFF  1F,30
1B26:  MOVFF  1E,2F
1B2A:  MOVFF  1D,2E
1B2E:  BRA    14E4
....................    
....................    // Los 4 numeros se distribuyen en el display
....................    
....................    // Encendemos primer display
....................    output_high(D2);
1B30:  BCF    F95.4
1B32:  BSF    F8C.4
....................    output_high(D3);
1B34:  BCF    F95.6
1B36:  BSF    F8C.6
....................    output_high(D4);
1B38:  BCF    F95.7
1B3A:  BSF    F8C.7
....................    output_low(D1);
1B3C:  BCF    F96.0
1B3E:  BCF    F8D.0
....................    
....................    if(numero < 10) // Un digito y tres decimales
1B40:  MOVFF  20,52
1B44:  MOVFF  1F,51
1B48:  MOVFF  1E,50
1B4C:  MOVFF  1D,4F
1B50:  CLRF   56
1B52:  CLRF   55
1B54:  MOVLW  20
1B56:  MOVWF  54
1B58:  MOVLW  82
1B5A:  MOVWF  53
1B5C:  CALL   0082
1B60:  BNC   1B68
....................       punto = 128; // Le sumamos para que el bit que activa el punto se active
1B62:  MOVLW  80
1B64:  MOVWF  21
1B66:  BRA    1B6A
....................    else
....................       punto = 0;
1B68:  CLRF   21
....................    
....................    output_b(vec_c[n1] + punto);
1B6A:  CLRF   03
1B6C:  MOVF   22,W
1B6E:  ADDLW  04
1B70:  MOVWF  FE9
1B72:  MOVLW  00
1B74:  ADDWFC 03,W
1B76:  MOVWF  FEA
1B78:  MOVF   21,W
1B7A:  ADDWF  FEF,W
1B7C:  CLRF   F93
1B7E:  MOVWF  F8A
....................    
....................    delay_ms(5);
1B80:  MOVLW  05
1B82:  MOVWF  26
1B84:  RCALL  1ADE
....................    
....................    // Encendemos segundo display
....................    output_high(D1);
1B86:  BCF    F96.0
1B88:  BSF    F8D.0
....................    output_high(D3);
1B8A:  BCF    F95.6
1B8C:  BSF    F8C.6
....................    output_high(D4);
1B8E:  BCF    F95.7
1B90:  BSF    F8C.7
....................    output_low(D2);
1B92:  BCF    F95.4
1B94:  BCF    F8C.4
....................    
....................    if(numero < 100 & !(numero < 10)) // Dos digitos y dos decimales
1B96:  MOVFF  20,52
1B9A:  MOVFF  1F,51
1B9E:  MOVFF  1E,50
1BA2:  MOVFF  1D,4F
1BA6:  CLRF   56
1BA8:  CLRF   55
1BAA:  MOVLW  48
1BAC:  MOVWF  54
1BAE:  MOVLW  85
1BB0:  MOVWF  53
1BB2:  CALL   0082
1BB6:  MOVLW  00
1BB8:  BTFSC  FD8.0
1BBA:  MOVLW  01
1BBC:  MOVWF  26
1BBE:  MOVFF  20,52
1BC2:  MOVFF  1F,51
1BC6:  MOVFF  1E,50
1BCA:  MOVFF  1D,4F
1BCE:  CLRF   56
1BD0:  CLRF   55
1BD2:  MOVLW  20
1BD4:  MOVWF  54
1BD6:  MOVLW  82
1BD8:  MOVWF  53
1BDA:  CALL   0082
1BDE:  MOVLW  00
1BE0:  BTFSS  FD8.0
1BE2:  MOVLW  01
1BE4:  ANDWF  26,W
1BE6:  BZ    1BEE
....................       punto = 128; // Le sumamos para que el bit que activa el punto se active
1BE8:  MOVLW  80
1BEA:  MOVWF  21
1BEC:  BRA    1BF0
....................    else
....................       punto = 0;
1BEE:  CLRF   21
....................    
....................    output_b(vec_c[n2] + punto);
1BF0:  CLRF   03
1BF2:  MOVF   23,W
1BF4:  ADDLW  04
1BF6:  MOVWF  FE9
1BF8:  MOVLW  00
1BFA:  ADDWFC 03,W
1BFC:  MOVWF  FEA
1BFE:  MOVF   21,W
1C00:  ADDWF  FEF,W
1C02:  CLRF   F93
1C04:  MOVWF  F8A
....................    
....................    delay_ms(5);
1C06:  MOVLW  05
1C08:  MOVWF  26
1C0A:  RCALL  1ADE
....................    
....................    // Encendemos tercer display
....................    output_high(D1);
1C0C:  BCF    F96.0
1C0E:  BSF    F8D.0
....................    output_high(D2);
1C10:  BCF    F95.4
1C12:  BSF    F8C.4
....................    output_high(D4);
1C14:  BCF    F95.7
1C16:  BSF    F8C.7
....................    output_low(D3);
1C18:  BCF    F95.6
1C1A:  BCF    F8C.6
....................    
....................    if((numero < 1000) && !(numero < 100) && !(numero < 10)) // Tres digitos y un decimal
1C1C:  MOVFF  20,52
1C20:  MOVFF  1F,51
1C24:  MOVFF  1E,50
1C28:  MOVFF  1D,4F
1C2C:  CLRF   56
1C2E:  CLRF   55
1C30:  MOVLW  7A
1C32:  MOVWF  54
1C34:  MOVLW  88
1C36:  MOVWF  53
1C38:  CALL   0082
1C3C:  BNC   1C88
1C3E:  MOVFF  20,52
1C42:  MOVFF  1F,51
1C46:  MOVFF  1E,50
1C4A:  MOVFF  1D,4F
1C4E:  CLRF   56
1C50:  CLRF   55
1C52:  MOVLW  48
1C54:  MOVWF  54
1C56:  MOVLW  85
1C58:  MOVWF  53
1C5A:  CALL   0082
1C5E:  BC    1C88
1C60:  MOVFF  20,52
1C64:  MOVFF  1F,51
1C68:  MOVFF  1E,50
1C6C:  MOVFF  1D,4F
1C70:  CLRF   56
1C72:  CLRF   55
1C74:  MOVLW  20
1C76:  MOVWF  54
1C78:  MOVLW  82
1C7A:  MOVWF  53
1C7C:  CALL   0082
1C80:  BC    1C88
....................       punto = 128; // Le sumamos para que el bit que activa el punto se active
1C82:  MOVLW  80
1C84:  MOVWF  21
1C86:  BRA    1C8A
....................    else
....................       punto = 0;
1C88:  CLRF   21
....................       
....................    output_b(vec_c[n3] + punto);
1C8A:  CLRF   03
1C8C:  MOVF   24,W
1C8E:  ADDLW  04
1C90:  MOVWF  FE9
1C92:  MOVLW  00
1C94:  ADDWFC 03,W
1C96:  MOVWF  FEA
1C98:  MOVF   21,W
1C9A:  ADDWF  FEF,W
1C9C:  CLRF   F93
1C9E:  MOVWF  F8A
....................    
....................    delay_ms(5);
1CA0:  MOVLW  05
1CA2:  MOVWF  26
1CA4:  RCALL  1ADE
....................    
....................    // Encendemos cuarto display
....................    output_high(D1);
1CA6:  BCF    F96.0
1CA8:  BSF    F8D.0
....................    output_high(D2);
1CAA:  BCF    F95.4
1CAC:  BSF    F8C.4
....................    output_high(D3);
1CAE:  BCF    F95.6
1CB0:  BSF    F8C.6
....................    output_low(D4);
1CB2:  BCF    F95.7
1CB4:  BCF    F8C.7
....................       
....................    output_b(vec_c[n4]);
1CB6:  CLRF   03
1CB8:  MOVF   25,W
1CBA:  ADDLW  04
1CBC:  MOVWF  FE9
1CBE:  MOVLW  00
1CC0:  ADDWFC 03,W
1CC2:  MOVWF  FEA
1CC4:  MOVFF  FEF,F8A
1CC8:  CLRF   F93
....................    
....................    delay_ms(5);
1CCA:  MOVLW  05
1CCC:  MOVWF  26
1CCE:  RCALL  1ADE
1CD0:  GOTO   20E4 (RETURN)
.................... }
.................... 
.................... void Descomponer(int *n1, int *n2, int *n3, int *n4, float numero) // Buscar forma de acortar
.................... {
....................    int16 entera;
....................    float aux, decimal;
....................    
....................    entera = (int16) numero; // Quitamos los decimales del numero
*
14E4:  MOVFF  31,52
14E8:  MOVFF  30,51
14EC:  MOVFF  2F,50
14F0:  MOVFF  2E,4F
14F4:  CALL   0004
14F8:  MOVFF  02,33
14FC:  MOVFF  01,32
....................    decimal = numero - entera; // Quitamos la parte entera del numero
1500:  MOVFF  33,54
1504:  MOVFF  32,53
1508:  CALL   004C
150C:  BSF    FD8.1
150E:  MOVFF  31,56
1512:  MOVFF  30,55
1516:  MOVFF  2F,54
151A:  MOVFF  2E,53
151E:  MOVFF  03,5A
1522:  MOVFF  02,59
1526:  MOVFF  01,58
152A:  MOVFF  00,57
152E:  CALL   0344
1532:  MOVFF  03,3B
1536:  MOVFF  02,3A
153A:  MOVFF  01,39
153E:  MOVFF  00,38
....................    
....................    if(numero < 10)
1542:  MOVFF  31,52
1546:  MOVFF  30,51
154A:  MOVFF  2F,50
154E:  MOVFF  2E,4F
1552:  CLRF   56
1554:  CLRF   55
1556:  MOVLW  20
1558:  MOVWF  54
155A:  MOVLW  82
155C:  MOVWF  53
155E:  CALL   0082
1562:  BTFSS  FD8.0
1564:  BRA    1718
....................    {
....................       *n1 = entera; // Sacamos las unidades
1566:  MOVFF  26,FE9
156A:  MOVFF  27,FEA
156E:  MOVFF  32,FEF
....................       aux = decimal * 10; // Separamos el primer decimal 
1572:  MOVFF  3B,52
1576:  MOVFF  3A,51
157A:  MOVFF  39,50
157E:  MOVFF  38,4F
1582:  CLRF   56
1584:  CLRF   55
1586:  MOVLW  20
1588:  MOVWF  54
158A:  MOVLW  82
158C:  MOVWF  53
158E:  CALL   0252
1592:  MOVFF  03,37
1596:  MOVFF  02,36
159A:  MOVFF  01,35
159E:  MOVFF  00,34
....................       *n2 = (int) aux;
15A2:  MOVFF  29,03
15A6:  MOVFF  28,FE9
15AA:  MOVFF  29,FEA
15AE:  MOVFF  37,52
15B2:  MOVFF  36,51
15B6:  MOVFF  35,50
15BA:  MOVFF  34,4F
15BE:  CALL   0004
15C2:  MOVFF  01,FEF
....................       aux -= (int) aux; // Borramos el primer decimal
15C6:  MOVFF  37,52
15CA:  MOVFF  36,51
15CE:  MOVFF  35,50
15D2:  MOVFF  34,4F
15D6:  CALL   0004
15DA:  CLRF   54
15DC:  MOVFF  01,53
15E0:  CALL   004C
15E4:  BSF    FD8.1
15E6:  MOVFF  37,56
15EA:  MOVFF  36,55
15EE:  MOVFF  35,54
15F2:  MOVFF  34,53
15F6:  MOVFF  03,5A
15FA:  MOVFF  02,59
15FE:  MOVFF  01,58
1602:  MOVFF  00,57
1606:  CALL   0344
160A:  MOVFF  03,37
160E:  MOVFF  02,36
1612:  MOVFF  01,35
1616:  MOVFF  00,34
....................       aux *= 10; // Separamos el segundo decimal
161A:  MOVFF  37,52
161E:  MOVFF  36,51
1622:  MOVFF  35,50
1626:  MOVFF  34,4F
162A:  CLRF   56
162C:  CLRF   55
162E:  MOVLW  20
1630:  MOVWF  54
1632:  MOVLW  82
1634:  MOVWF  53
1636:  CALL   0252
163A:  MOVFF  03,37
163E:  MOVFF  02,36
1642:  MOVFF  01,35
1646:  MOVFF  00,34
....................       *n3 = (int) aux;
164A:  MOVFF  2B,03
164E:  MOVFF  2A,FE9
1652:  MOVFF  2B,FEA
1656:  MOVFF  37,52
165A:  MOVFF  36,51
165E:  MOVFF  35,50
1662:  MOVFF  34,4F
1666:  CALL   0004
166A:  MOVFF  01,FEF
....................       aux -= (int) aux; // Borramos el segundo decimal
166E:  MOVFF  37,52
1672:  MOVFF  36,51
1676:  MOVFF  35,50
167A:  MOVFF  34,4F
167E:  CALL   0004
1682:  CLRF   54
1684:  MOVFF  01,53
1688:  CALL   004C
168C:  BSF    FD8.1
168E:  MOVFF  37,56
1692:  MOVFF  36,55
1696:  MOVFF  35,54
169A:  MOVFF  34,53
169E:  MOVFF  03,5A
16A2:  MOVFF  02,59
16A6:  MOVFF  01,58
16AA:  MOVFF  00,57
16AE:  CALL   0344
16B2:  MOVFF  03,37
16B6:  MOVFF  02,36
16BA:  MOVFF  01,35
16BE:  MOVFF  00,34
....................       aux *= 10; // Separamos el tercer decimal
16C2:  MOVFF  37,52
16C6:  MOVFF  36,51
16CA:  MOVFF  35,50
16CE:  MOVFF  34,4F
16D2:  CLRF   56
16D4:  CLRF   55
16D6:  MOVLW  20
16D8:  MOVWF  54
16DA:  MOVLW  82
16DC:  MOVWF  53
16DE:  CALL   0252
16E2:  MOVFF  03,37
16E6:  MOVFF  02,36
16EA:  MOVFF  01,35
16EE:  MOVFF  00,34
....................       *n4 = (int) aux;
16F2:  MOVFF  2D,03
16F6:  MOVFF  2C,FE9
16FA:  MOVFF  2D,FEA
16FE:  MOVFF  37,52
1702:  MOVFF  36,51
1706:  MOVFF  35,50
170A:  MOVFF  34,4F
170E:  CALL   0004
1712:  MOVFF  01,FEF
....................    }
1716:  BRA    1ADA
....................    else if(numero < 100)
1718:  MOVFF  31,52
171C:  MOVFF  30,51
1720:  MOVFF  2F,50
1724:  MOVFF  2E,4F
1728:  CLRF   56
172A:  CLRF   55
172C:  MOVLW  48
172E:  MOVWF  54
1730:  MOVLW  85
1732:  MOVWF  53
1734:  CALL   0082
1738:  BTFSS  FD8.0
173A:  BRA    187C
....................    {
....................       *n1 = entera / 10; // Sacamos las decenas
173C:  MOVFF  27,03
1740:  MOVFF  26,FE9
1744:  MOVFF  27,FEA
1748:  MOVFF  33,41
174C:  MOVFF  32,40
1750:  CLRF   43
1752:  MOVLW  0A
1754:  MOVWF  42
1756:  RCALL  1484
1758:  MOVFF  01,FEF
....................       *n2 = entera - (*n1*10); // Sacamos las unidades
175C:  MOVFF  26,FE9
1760:  MOVFF  27,FEA
1764:  MOVF   FEF,W
1766:  MULLW  0A
1768:  MOVF   FF3,W
176A:  SUBWF  32,W
176C:  MOVWF  00
176E:  MOVLW  00
1770:  SUBWFB 33,W
1772:  MOVFF  29,FEA
1776:  MOVFF  28,FE9
177A:  MOVFF  00,FEF
....................       aux = decimal * 10; // Separamos el primer decimal
177E:  MOVFF  3B,52
1782:  MOVFF  3A,51
1786:  MOVFF  39,50
178A:  MOVFF  38,4F
178E:  CLRF   56
1790:  CLRF   55
1792:  MOVLW  20
1794:  MOVWF  54
1796:  MOVLW  82
1798:  MOVWF  53
179A:  CALL   0252
179E:  MOVFF  03,37
17A2:  MOVFF  02,36
17A6:  MOVFF  01,35
17AA:  MOVFF  00,34
....................       *n3 = (int) aux;
17AE:  MOVFF  2B,03
17B2:  MOVFF  2A,FE9
17B6:  MOVFF  2B,FEA
17BA:  MOVFF  37,52
17BE:  MOVFF  36,51
17C2:  MOVFF  35,50
17C6:  MOVFF  34,4F
17CA:  CALL   0004
17CE:  MOVFF  01,FEF
....................       aux -= (int) aux; // Borramos el primer decimal
17D2:  MOVFF  37,52
17D6:  MOVFF  36,51
17DA:  MOVFF  35,50
17DE:  MOVFF  34,4F
17E2:  CALL   0004
17E6:  CLRF   54
17E8:  MOVFF  01,53
17EC:  CALL   004C
17F0:  BSF    FD8.1
17F2:  MOVFF  37,56
17F6:  MOVFF  36,55
17FA:  MOVFF  35,54
17FE:  MOVFF  34,53
1802:  MOVFF  03,5A
1806:  MOVFF  02,59
180A:  MOVFF  01,58
180E:  MOVFF  00,57
1812:  CALL   0344
1816:  MOVFF  03,37
181A:  MOVFF  02,36
181E:  MOVFF  01,35
1822:  MOVFF  00,34
....................       aux *= 10; // Separamos el segundo decimal
1826:  MOVFF  37,52
182A:  MOVFF  36,51
182E:  MOVFF  35,50
1832:  MOVFF  34,4F
1836:  CLRF   56
1838:  CLRF   55
183A:  MOVLW  20
183C:  MOVWF  54
183E:  MOVLW  82
1840:  MOVWF  53
1842:  CALL   0252
1846:  MOVFF  03,37
184A:  MOVFF  02,36
184E:  MOVFF  01,35
1852:  MOVFF  00,34
....................       *n4 = (int) aux;
1856:  MOVFF  2D,03
185A:  MOVFF  2C,FE9
185E:  MOVFF  2D,FEA
1862:  MOVFF  37,52
1866:  MOVFF  36,51
186A:  MOVFF  35,50
186E:  MOVFF  34,4F
1872:  CALL   0004
1876:  MOVFF  01,FEF
....................    }
187A:  BRA    1ADA
....................    else if(numero < 1000)
187C:  MOVFF  31,52
1880:  MOVFF  30,51
1884:  MOVFF  2F,50
1888:  MOVFF  2E,4F
188C:  CLRF   56
188E:  CLRF   55
1890:  MOVLW  7A
1892:  MOVWF  54
1894:  MOVLW  88
1896:  MOVWF  53
1898:  CALL   0082
189C:  BNC   198E
....................    {
....................       *n1 = entera / 100; // Sacamos las centenas
189E:  MOVFF  27,03
18A2:  MOVFF  26,FE9
18A6:  MOVFF  27,FEA
18AA:  MOVFF  33,41
18AE:  MOVFF  32,40
18B2:  CLRF   43
18B4:  MOVLW  64
18B6:  MOVWF  42
18B8:  RCALL  1484
18BA:  MOVFF  01,FEF
....................       *n2 = entera / 10;
18BE:  MOVFF  29,03
18C2:  MOVFF  28,FE9
18C6:  MOVFF  29,FEA
18CA:  MOVFF  33,41
18CE:  MOVFF  32,40
18D2:  CLRF   43
18D4:  MOVLW  0A
18D6:  MOVWF  42
18D8:  RCALL  1484
18DA:  MOVFF  01,FEF
....................       *n2 -= (*n1*10); // Sacamos las decenas
18DE:  MOVFF  29,FEA
18E2:  MOVFF  28,FE9
18E6:  MOVFF  FEF,3E
18EA:  MOVFF  26,FE9
18EE:  MOVFF  27,FEA
18F2:  MOVF   FEF,W
18F4:  MULLW  0A
18F6:  MOVF   FF3,W
18F8:  SUBWF  3E,W
18FA:  MOVFF  29,FEA
18FE:  MOVFF  28,FE9
1902:  MOVWF  FEF
....................       *n3 = entera - ((*n1*100) + (*n2*10)); // Sacamos las unidades
1904:  MOVFF  26,FE9
1908:  MOVFF  27,FEA
190C:  MOVF   FEF,W
190E:  MULLW  64
1910:  MOVFF  FF3,3E
1914:  MOVFF  28,FE9
1918:  MOVFF  29,FEA
191C:  MOVF   FEF,W
191E:  MULLW  0A
1920:  MOVF   FF3,W
1922:  ADDWF  3E,W
1924:  SUBWF  32,W
1926:  MOVWF  00
1928:  MOVLW  00
192A:  SUBWFB 33,W
192C:  MOVFF  2B,FEA
1930:  MOVFF  2A,FE9
1934:  MOVFF  00,FEF
....................       aux = decimal * 10; // Separamos el primer decimal
1938:  MOVFF  3B,52
193C:  MOVFF  3A,51
1940:  MOVFF  39,50
1944:  MOVFF  38,4F
1948:  CLRF   56
194A:  CLRF   55
194C:  MOVLW  20
194E:  MOVWF  54
1950:  MOVLW  82
1952:  MOVWF  53
1954:  CALL   0252
1958:  MOVFF  03,37
195C:  MOVFF  02,36
1960:  MOVFF  01,35
1964:  MOVFF  00,34
....................       *n4 = (int) aux;
1968:  MOVFF  2D,03
196C:  MOVFF  2C,FE9
1970:  MOVFF  2D,FEA
1974:  MOVFF  37,52
1978:  MOVFF  36,51
197C:  MOVFF  35,50
1980:  MOVFF  34,4F
1984:  CALL   0004
1988:  MOVFF  01,FEF
....................    }
198C:  BRA    1ADA
....................    else if(numero < 10000)
198E:  MOVFF  31,52
1992:  MOVFF  30,51
1996:  MOVFF  2F,50
199A:  MOVFF  2E,4F
199E:  CLRF   56
19A0:  MOVLW  40
19A2:  MOVWF  55
19A4:  MOVLW  1C
19A6:  MOVWF  54
19A8:  MOVLW  8C
19AA:  MOVWF  53
19AC:  CALL   0082
19B0:  BTFSS  FD8.0
19B2:  BRA    1ADA
....................    {
....................       *n1 = entera / 1000; // Sacamos los millares
19B4:  MOVFF  27,03
19B8:  MOVFF  26,FE9
19BC:  MOVFF  27,FEA
19C0:  MOVFF  33,41
19C4:  MOVFF  32,40
19C8:  MOVLW  03
19CA:  MOVWF  43
19CC:  MOVLW  E8
19CE:  MOVWF  42
19D0:  RCALL  1484
19D2:  MOVFF  01,FEF
....................       *n2 = (entera - (*n1*1000)) / 100; // Sacamos las centenas
19D6:  MOVFF  27,03
19DA:  MOVFF  26,FE9
19DE:  MOVFF  27,FEA
19E2:  CLRF   40
19E4:  MOVFF  FEF,3F
19E8:  MOVLW  03
19EA:  MOVWF  42
19EC:  MOVLW  E8
19EE:  MOVWF  41
19F0:  RCALL  14C6
19F2:  MOVFF  02,03
19F6:  MOVF   01,W
19F8:  SUBWF  32,W
19FA:  MOVWF  3E
19FC:  MOVF   02,W
19FE:  SUBWFB 33,W
1A00:  MOVWF  3F
1A02:  MOVWF  41
1A04:  MOVFF  3E,40
1A08:  CLRF   43
1A0A:  MOVLW  64
1A0C:  MOVWF  42
1A0E:  RCALL  1484
1A10:  MOVFF  29,FEA
1A14:  MOVFF  28,FE9
1A18:  MOVFF  01,FEF
....................       *n3 = entera / 10;
1A1C:  MOVFF  2B,03
1A20:  MOVFF  2A,FE9
1A24:  MOVFF  2B,FEA
1A28:  MOVFF  33,41
1A2C:  MOVFF  32,40
1A30:  CLRF   43
1A32:  MOVLW  0A
1A34:  MOVWF  42
1A36:  RCALL  1484
1A38:  MOVFF  01,FEF
....................       *n3 -= ((*n1*100) + (*n2*10)); // Sacamos las decenas
1A3C:  MOVFF  2B,FEA
1A40:  MOVFF  2A,FE9
1A44:  MOVFF  FEF,3E
1A48:  MOVFF  26,FE9
1A4C:  MOVFF  27,FEA
1A50:  MOVF   FEF,W
1A52:  MULLW  64
1A54:  MOVFF  FF3,3F
1A58:  MOVFF  28,FE9
1A5C:  MOVFF  29,FEA
1A60:  MOVF   FEF,W
1A62:  MULLW  0A
1A64:  MOVF   FF3,W
1A66:  ADDWF  3F,W
1A68:  SUBWF  3E,W
1A6A:  MOVFF  2B,FEA
1A6E:  MOVFF  2A,FE9
1A72:  MOVWF  FEF
....................       *n4 = entera - ((*n1*1000) + (*n2*100) + (*n3*10)); // Sacamos las unidades
1A74:  MOVFF  27,03
1A78:  MOVFF  26,FE9
1A7C:  MOVFF  27,FEA
1A80:  CLRF   40
1A82:  MOVFF  FEF,3F
1A86:  MOVLW  03
1A88:  MOVWF  42
1A8A:  MOVLW  E8
1A8C:  MOVWF  41
1A8E:  RCALL  14C6
1A90:  MOVFF  02,3F
1A94:  MOVFF  01,3E
1A98:  MOVFF  28,FE9
1A9C:  MOVFF  29,FEA
1AA0:  MOVF   FEF,W
1AA2:  MULLW  64
1AA4:  MOVF   FF3,W
1AA6:  ADDWF  3E,F
1AA8:  MOVLW  00
1AAA:  ADDWFC 3F,F
1AAC:  MOVFF  2A,FE9
1AB0:  MOVFF  2B,FEA
1AB4:  MOVF   FEF,W
1AB6:  MULLW  0A
1AB8:  MOVF   FF3,W
1ABA:  ADDWF  3E,W
1ABC:  MOVWF  01
1ABE:  MOVLW  00
1AC0:  ADDWFC 3F,W
1AC2:  MOVWF  03
1AC4:  MOVF   01,W
1AC6:  SUBWF  32,W
1AC8:  MOVWF  00
1ACA:  MOVF   03,W
1ACC:  SUBWFB 33,W
1ACE:  MOVFF  2D,FEA
1AD2:  MOVFF  2C,FE9
1AD6:  MOVFF  00,FEF
....................    }
1ADA:  GOTO   1B30 (RETURN)
.................... }
.................... 
.................... 
.................... // Ver como definir el tiempo muerto para evitar un microcorto. El tiempo muerto debe abarcar entre 1/100 -> 1/10 del periodo del PWM
....................       // PWM al 50% detiene el motor pues avanza lo mismo que retrocede
....................       // PWM < 50% gira el motor hacia un sentido
....................       // PWN > 50% gira el motor hacia el sentido contrario
....................       
....................       // Ver si hay que pasar gradualmente de un lado a otro o se puede poner el duty al 0 % y de golpe al 100 %

Configuration Fuses:
   Word  1: C020   PLL1 CPUDIV1 USBDIV XT FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
